<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Hourglass">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="Hourglass — Watch time pass, choose how to live.">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23667eea' width='100' height='100' rx='20'/><text x='50' y='68' font-size='50' text-anchor='middle' fill='white'>⏱️</text></svg>">
    <title>Hourglass — Watch time pass, choose how to live</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            min-height: calc(100vh - 40px);
        }

        .app-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 30px;
            text-align: center;
        }

        .app-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .app-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .app-header .slogan {
            font-style: italic;
        }

        .management-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            color: white;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .management-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: white;
            transform: scale(1.05);
        }

        /* Management Modal */
        .management-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .management-modal.active {
            display: flex;
        }

        .management-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .management-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .management-header h2 {
            font-size: 1.4rem;
            margin: 0;
        }

        .management-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }

        .management-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .management-section {
            margin-bottom: 25px;
        }

        .management-section h3 {
            font-size: 1.1rem;
            color: #374151;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .management-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .management-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .management-item:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }

        .management-item-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .management-item-icon {
            font-size: 1.3rem;
        }

        .management-item-name {
            font-weight: 500;
            color: #1f2937;
        }

        .management-item-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            background: #e0f2fe;
            color: #0369a1;
            border-radius: 10px;
            margin-left: 8px;
        }

        .management-item-actions {
            display: flex;
            gap: 6px;
        }

        .management-item-actions button {
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .mgmt-edit-btn {
            background: #e0f2fe;
            color: #0369a1;
        }

        .mgmt-edit-btn:hover {
            background: #bae6fd;
        }

        .mgmt-delete-btn {
            background: #fee2e2;
            color: #dc2626;
        }

        .mgmt-delete-btn:hover {
            background: #fecaca;
        }

        .mgmt-add-btn {
            width: 100%;
            padding: 12px;
            background: #f0fdf4;
            border: 2px dashed #86efac;
            border-radius: 8px;
            color: #16a34a;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mgmt-add-btn:hover {
            background: #dcfce7;
            border-color: #22c55e;
        }

        .subcategory-expand {
            padding: 6px 10px;
            background: #f3f4f6;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6b7280;
            transition: all 0.2s;
        }

        .subcategory-expand:hover {
            background: #e5e7eb;
        }

        .subcategory-list {
            margin-top: 8px;
            margin-left: 30px;
            padding: 10px;
            background: #fafafa;
            border-radius: 8px;
            display: none;
        }

        .subcategory-list.expanded {
            display: block;
        }

        .subcategory-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .subcategory-item:last-child {
            margin-bottom: 0;
        }

        .subcategory-item-name {
            color: #4b5563;
        }

        .subcategory-item-badge {
            font-size: 0.65rem;
            padding: 2px 5px;
            background: #fef3c7;
            color: #92400e;
            border-radius: 8px;
            margin-left: 6px;
        }

        .reset-section {
            padding-top: 15px;
            border-top: 1px solid #e5e7eb;
        }

        .reset-btn {
            width: 100%;
            padding: 12px;
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            color: #dc2626;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            background: #fee2e2;
        }

        .view-toggle {
            display: flex;
            border-bottom: 2px solid #e5e7eb;
            background: #f9fafb;
        }

        .view-toggle button {
            flex: 1;
            padding: 15px;
            border: none;
            background: transparent;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            color: #6b7280;
            transition: all 0.3s;
        }

        .view-toggle button.active {
            color: #667eea;
            background: white;
            border-bottom: 3px solid #667eea;
        }

        .view-toggle button:hover {
            background: #f3f4f6;
        }

        .tracker-container, .logs-container {
            padding: 30px;
        }

        .overview-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #e5e7eb;
        }

        .timer-display {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
        }

        .time {
            font-size: 4rem;
            font-weight: 700;
            color: #1f2937;
            font-family: 'Courier New', monospace;
            margin-bottom: 20px;
        }

        .timer-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn {
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-start {
            background: #10b981;
            color: white;
        }

        .btn-start:hover {
            background: #059669;
        }

        .btn-stop {
            background: #ef4444;
            color: white;
        }

        .btn-stop:hover {
            background: #dc2626;
        }

        .btn-reset {
            background: #6b7280;
            color: white;
        }

        .btn-reset:hover {
            background: #4b5563;
        }

        .category-selector {
            margin-bottom: 30px;
        }

        .category-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .category-selector h3 {
            color: #1f2937;
            font-size: 1.2rem;
            margin: 0;
        }

        .manage-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 20px;
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .manage-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .categories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, 100px);
            gap: 12px;
            justify-content: center;
        }

        .category-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px 8px 10px;
            border: 2px solid #f0f0f0;
            border-radius: 16px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            width: 100px;
            height: 110px;
            min-width: 100px;
            max-width: 100px;
            min-height: 110px;
            max-height: 110px;
            box-sizing: border-box;
        }

        .category-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
            border-color: #e0e0e0;
        }

        .category-card.active {
            transform: scale(1.02);
            border-color: transparent;
        }

        .category-icon {
            font-size: 1.5rem;
            margin-bottom: 8px;
            width: 52px;
            height: 52px;
            min-width: 52px;
            min-height: 52px;
            max-width: 52px;
            max-height: 52px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            border-radius: 14px;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .category-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: #374151;
            text-align: center;
            line-height: 1.2;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .subcategory-panel {
            margin-top: 6px;
        }

        .subcategory-panel select {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.85rem;
            background: white;
            cursor: pointer;
            color: #374151;
        }

        .subcategory-panel select:focus {
            outline: none;
            border-color: #667eea;
        }

        .subcategory-panel select:disabled {
            background: #f3f4f6;
            cursor: not-allowed;
        }

        .custom-subs-list {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #bae6fd;
        }

        .custom-subs-list-title {
            font-size: 0.8rem;
            color: #6b7280;
            margin-bottom: 6px;
        }

        .custom-sub-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            background: white;
            border: 1px solid #e0f2fe;
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 0.85rem;
        }

        .custom-sub-item span {
            color: #0369a1;
        }

        .custom-sub-actions {
            display: flex;
            gap: 4px;
        }

        .custom-sub-actions button {
            padding: 2px 6px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: background 0.2s;
        }

        .edit-sub-btn {
            background: #e0f2fe;
            color: #0369a1;
        }

        .edit-sub-btn:hover {
            background: #bae6fd;
        }

        .delete-sub-btn {
            background: #fee2e2;
            color: #dc2626;
        }

        .delete-sub-btn:hover {
            background: #fecaca;
        }

        .active-timer-info {
            padding: 15px;
            background: #dbeafe;
            border-left: 4px solid #3b82f6;
            border-radius: 8px;
            color: #1e40af;
            font-size: 0.95rem;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .category-stats {
            margin-bottom: 30px;
            padding: 20px;
            background: #f9fafb;
            border-radius: 12px;
        }

        .category-stats h3 {
            margin-bottom: 20px;
            color: #1f2937;
        }

        .category-bars {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .category-bar-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .category-bar-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            width: 100%;
            max-width: 700px;
            max-height: 85vh;
            overflow-y: auto;
            padding: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e5e7eb;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.3rem;
            color: #111827;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .close-modal:hover {
            background: #f3f4f6;
        }

        .edit-log-item {
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 16px;
            background: #fafbfc;
        }

        .edit-log-item:hover {
            border-color: #d1d5db;
        }

        .edit-log-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 10px;
        }

        .edit-log-row label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #4b5563;
            min-width: 60px;
        }

        .edit-log-row input, .edit-log-row select {
            padding: 8px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .edit-log-row input[type="text"] {
            flex: 1;
            min-width: 150px;
        }

        .edit-log-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
        }

        .btn-save-log {
            background: #10b981;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-save-log:hover {
            background: #059669;
        }

        .btn-delete-log {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-delete-log:hover {
            background: #dc2626;
        }

        .category-bar-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: 600;
            color: #1f2937;
        }

        .category-bar {
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }

        .category-bar-fill {
            height: 100%;
            transition: width 0.3s;
            border-radius: 4px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
        }

        .logs-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .log-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #f9fafb;
            border-radius: 10px;
            transition: all 0.3s;
            border-left: 4px solid transparent;
        }

        .log-item:hover {
            background: #f3f4f6;
            transform: translateX(5px);
        }

        .log-icon {
            font-size: 2rem;
            width: 50px;
            text-align: center;
        }

        .log-details {
            flex: 1;
        }

        .log-category {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
        }


        .log-time {
            color: #9ca3af;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }

        .log-time-period {
            color: #6b7280;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .log-duration {
            font-size: 1.2rem;
            font-weight: 700;
            color: #1f2937;
            font-family: 'Courier New', monospace;
            min-width: 80px;
            text-align: right;
        }

        .delete-btn {
            background: transparent;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            opacity: 0.6;
            transition: all 0.3s;
        }

        .delete-btn:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .hidden {
            display: none;
        }

        .add-category-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            border: 3px dashed #d1d5db;
            border-radius: 12px;
            background: #f9fafb;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 100px;
        }

        .add-category-card:hover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: translateY(-2px);
        }

        .add-category-card .add-icon {
            font-size: 2.5rem;
            color: #9ca3af;
            margin-bottom: 8px;
        }

        .add-category-card:hover .add-icon {
            color: #667eea;
        }

        .add-category-card .add-text {
            font-size: 0.85rem;
            color: #6b7280;
            font-weight: 600;
        }

        .add-category-card:hover .add-text {
            color: #667eea;
        }

        .btn-add {
            background: #667eea;
            color: white;
            padding: 8px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .btn-add:hover {
            background: #5568d3;
            transform: translateY(-1px);
        }

        .btn-add:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .category-item-container {
            position: relative;
        }

        .category-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .category-item-container:hover .category-actions {
            opacity: 1;
        }

        .edit-category-btn,
        .delete-category-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            width: 26px;
            height: 26px;
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .edit-category-btn:hover {
            background: #e0f2fe;
            border-color: #0ea5e9;
        }

        .delete-category-btn:hover {
            background: #fee2e2;
            border-color: #ef4444;
        }

        .reset-defaults-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px;
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            background: #f9fafb;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 80px;
        }

        .reset-defaults-card:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .reset-defaults-card .add-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .reset-defaults-card .add-text {
            font-size: 0.8rem;
            color: #6b7280;
        }

        .category-card-wrapper {
            position: relative;
            width: 100px;
        }

        .category-subcategories {
            margin-top: 10px;
            padding: 15px;
            background: #f0f9ff;
            border-radius: 10px;
            border: 2px solid #bae6fd;
            display: none;
        }

        .category-subcategories.show {
            display: block;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); background: #dbeafe; }
            100% { transform: scale(1); }
        }

        .subcategory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .subcategory-header h4 {
            margin: 0;
            color: #1f2937;
            font-size: 0.9rem;
        }

        .subcategory-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .subcategory-input-group input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #bae6fd;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .subcategory-input-group input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .subcategory-input-group input:disabled {
            background: #f3f4f6;
            cursor: not-allowed;
        }

        .subcategory-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .subcategory-tag {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 12px;
            background: white;
            border: 2px solid #bae6fd;
            border-radius: 20px;
            font-size: 0.85rem;
            color: #1f2937;
        }

        .subcategory-tag .delete-subcategory {
            background: transparent;
            border: none;
            color: #ef4444;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .subcategory-tag .delete-subcategory:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .subcategory-selector {
            margin-top: 15px;
            padding: 15px;
            background: #f9fafb;
            border-radius: 10px;
        }

        .subcategory-selector label {
            display: block;
            margin-bottom: 8px;
            color: #1f2937;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .subcategory-selector select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.95rem;
            background: white;
        }

        .subcategory-selector select:focus {
            outline: none;
            border-color: #667eea;
        }

        .subcategory-selector select:disabled {
            background: #f3f4f6;
            cursor: not-allowed;
        }

        .manual-entry-section {
            margin-top: 30px;
            padding: 20px;
            background: #fef3c7;
            border-radius: 12px;
            border: 2px solid #fcd34d;
        }

        .manual-entry-section h3 {
            margin-bottom: 15px;
            color: #1f2937;
            font-size: 1.1rem;
        }

        .manual-entry-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .manual-entry-form .form-group {
            min-width: 120px;
        }

        .manual-entry-form input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-size: 0.95rem;
        }

        .manual-entry-form input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .time-input-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .time-input-group input {
            flex: 1;
        }

        .time-input-group span {
            color: #6b7280;
            font-weight: 600;
        }

        /* Goals Section */
        .goals-section {
            margin-top: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            border-radius: 12px;
            border: 2px solid #7dd3fc;
        }

        .goals-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .goals-header h3 {
            margin: 0;
            color: #1e40af;
            font-size: 1.1rem;
        }

        .btn-goal-add {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .btn-goal-add:hover {
            background: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .goal-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .goal-modal.hidden {
            display: none;
        }

        .goal-modal-content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .goal-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .goal-modal-header h3 {
            margin: 0;
            color: #1e40af;
            font-size: 1.2rem;
        }

        .goal-modal-body {
            margin-bottom: 20px;
        }

        .goal-modal-actions {
            display: flex;
            gap: 10px;
        }

        .goal-modal-actions .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .btn-delete {
            background: #ef4444;
            color: white;
        }

        .btn-delete:hover {
            background: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }

        .goal-input-group {
            margin-bottom: 15px;
        }

        .goal-input-group label {
            display: block;
            margin-bottom: 8px;
            color: #1e40af;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .goal-input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #bfdbfe;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: border-color 0.3s ease;
        }

        .goal-input-group input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .goals-edit-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .goals-edit-actions .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .btn-save {
            background: #10b981;
            color: white;
        }

        .btn-save:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
        }

        .btn-cancel {
            background: #ef4444;
            color: white;
        }

        .btn-cancel:hover {
            background: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }

        .goals-display {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .goal-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #bfdbfe;
        }

        .goal-item-repeat {
            border-color: #a78bfa;
            background: linear-gradient(135deg, #ffffff 0%, #faf5ff 100%);
        }

        .goal-repeat-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%);
            color: white;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(167, 139, 250, 0.3);
        }

        .goal-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .goal-item-title {
            font-weight: 600;
            color: #1e40af;
            font-size: 0.95rem;
            flex: 1;
        }

        .goal-item-progress {
            font-weight: 600;
            color: #3b82f6;
            font-size: 0.9rem;
            margin-right: 10px;
        }

        .goal-item-actions {
            display: flex;
            gap: 8px;
        }

        .goal-item-edit-btn,
        .goal-item-delete-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            background: #e0e7ff;
            color: #3b82f6;
        }

        .goal-item-edit-btn:hover {
            background: #3b82f6;
            color: white;
        }

        .goal-item-delete-btn:hover {
            background: #ef4444;
            color: white;
        }

        .goal-progress-bar-container {
            width: 100%;
            height: 24px;
            background: #e0e7ff;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin-top: 8px;
        }

        .goal-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%);
            border-radius: 12px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .goal-progress-bar.over-goal {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
        }

        .goal-progress-bar.warning {
            background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
        }

        .goal-progress-text {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            font-weight: 600;
            color: #1e40af;
            z-index: 1;
        }

        /* 24h overview */
        .overview-header {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .overview-header h3 {
            color: #1f2937;
            font-size: 1.2rem;
        }

        .overview-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .overview-controls label {
            font-weight: 600;
            color: #374151;
            font-size: 0.9rem;
        }

        .overview-controls input[type="date"] {
            padding: 8px 10px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.95rem;
            background: white;
        }

        .timeline {
            position: relative;
            background: #ffffff;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
        }

        .timeline-grid {
            position: relative;
            height: 720px; /* 24h * 30px = half-scale for clarity */
        }

        .timeline-hour {
            position: absolute;
            left: 0;
            right: 0;
            height: 60px;
            border-top: 1px solid #eef2f7;
            display: flex;
            align-items: flex-start;
        }

        .timeline-hour-label {
            width: 64px;
            padding: 6px 8px;
            font-size: 0.85rem;
            color: #6b7280;
            font-family: 'Courier New', monospace;
        }

        .timeline-hour-line {
            flex: 1;
            height: 100%;
        }

        .timeline-events {
            position: absolute;
            top: 0;
            left: 72px;
            right: 10px;
            bottom: 0;
        }

        .timeline-event {
            position: absolute;
            left: 0;
            right: 0;
            border-radius: 10px;
            padding: 10px 12px;
            color: #111827;
            background: rgba(59, 130, 246, 0.12);
            border: 2px solid rgba(59, 130, 246, 0.35);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .timeline-event-time {
            font-size: 0.8rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 3px;
        }

        .timeline-event-category {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .timeline-event-category .cat-icon {
            font-size: 1.1rem;
        }

        .timeline-event-sub {
            font-size: 0.85rem;
            color: #6b7280;
            margin-bottom: 3px;
        }

        .timeline-event-duration {
            font-size: 0.85rem;
            font-weight: 600;
            color: #059669;
            background: rgba(5, 150, 105, 0.1);
            padding: 2px 8px;
            border-radius: 10px;
            display: inline-block;
            width: fit-content;
        }

        .timeline-event-meta {
            font-size: 0.85rem;
            color: #374151;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .timeline-empty {
            padding: 30px;
            text-align: center;
            color: #6b7280;
        }

        /* Overview Table Styles */
        .overview-table-container {
            overflow-x: auto;
        }

        .overview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .overview-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .overview-table th {
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
        }

        .overview-table tbody tr {
            border-bottom: 1px solid #e5e7eb;
            transition: background 0.2s;
        }

        .overview-table tbody tr:hover {
            background: #f9fafb;
        }

        .overview-table td {
            padding: 12px 15px;
            vertical-align: middle;
        }

        .overview-table .col-num {
            width: 40px;
            text-align: center;
            color: #9ca3af;
            font-weight: 600;
        }

        .overview-table .col-time {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: #374151;
            white-space: nowrap;
        }

        .overview-table .col-category {
            min-width: 120px;
        }

        .overview-table .cat-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 5px 12px;
            border-radius: 20px;
            border: 2px solid;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .overview-table .col-sub {
            color: #6b7280;
        }

        .overview-table .col-duration {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            color: #059669;
            background: #ecfdf5;
            border-radius: 6px;
            text-align: center;
        }

        .overview-table tfoot {
            background: #f3f4f6;
            border-top: 2px solid #e5e7eb;
        }

        .overview-table tfoot td {
            padding: 14px 15px;
            font-weight: 700;
        }

        .overview-table .total-label {
            text-align: right;
            color: #374151;
        }

        .overview-table .total-value {
            font-family: 'Courier New', monospace;
            color: #059669;
            background: #d1fae5;
            border-radius: 6px;
            text-align: center;
            font-size: 1rem;
        }

        /* Chart Styles */
        .charts-row-container {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .charts-row-container > .chart-container {
            flex: 1;
            min-width: 400px;
            margin-bottom: 0;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .charts-row-container > .chart-container > div:last-child {
            flex: 1;
            min-height: 320px;
        }

        .chart-container {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 1px 4px rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(226, 232, 240, 0.8);
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: visible;
        }

        .chart-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .chart-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #111827;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e5e7eb;
        }

        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .bar-item {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 8px 0;
        }

        .bar-label {
            min-width: 140px;
            font-weight: 600;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .bar-container {
            flex: 1;
            height: 36px;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            border-radius: 18px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        .bar-fill {
            height: 100%;
            border-radius: 18px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 12px;
            color: white;
            font-weight: 700;
            font-size: 0.875rem;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 70px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .bar-value {
            min-width: 90px;
            text-align: right;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            color: #059669;
            font-size: 0.95rem;
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            padding: 4px 10px;
            border-radius: 8px;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .chart-card-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 8px;
        }

        .chart-card-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #1f2937;
            font-family: 'Courier New', monospace;
        }

        .day-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .day-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .day-card-date {
            font-size: 0.85rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .day-card-total {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }

        /* Histogram and Line Chart Styles */
        .histogram-chart {
            display: flex;
            align-items: flex-end;
            gap: 10px;
            height: 280px;
            padding: 24px 16px 16px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            margin-top: 20px;
            border: 1px solid #e2e8f0;
        }

        .histogram-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 45px;
        }

        .histogram-bar-column {
            width: 100%;
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
            border-radius: 6px 6px 0 0;
            position: relative;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .histogram-bar-column:hover {
            opacity: 0.9;
            transform: scaleY(1.08) translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }

        .histogram-bar-label {
            font-size: 0.8rem;
            color: #475569;
            text-align: center;
            font-weight: 600;
            writing-mode: horizontal-tb;
            transform: rotate(-45deg);
            transform-origin: center;
            white-space: nowrap;
            margin-top: 4px;
        }

        .histogram-bar-value {
            position: absolute;
            top: -28px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            font-weight: 700;
            color: #1f2937;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            padding: 4px 8px;
            border-radius: 6px;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            font-family: 'Courier New', monospace;
        }

        .line-chart-container {
            position: relative;
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            margin-top: 12px;
            border: 1px solid #e2e8f0;
            overflow: visible;
            min-height: 320px;
        }

        .line-chart-svg {
            width: 100%;
            height: auto;
            min-height: 300px;
            display: block;
            overflow: visible;
        }

        #weekHistogramContainer,
        #weekLineChartContainer,
        #monthHistogramContainer,
        #monthLineChartContainer,
        #yearHistogramContainer,
        #yearLineChartContainer {
            width: 100%;
            overflow: visible;
            min-height: 320px;
        }

        #weekLineChartContainer .line-chart-container,
        #monthLineChartContainer .line-chart-container,
        #yearLineChartContainer .line-chart-container {
            margin-top: 0;
            overflow: visible;
            min-height: 320px;
        }

        #weekHistogramContainer .histogram-chart,
        #monthHistogramContainer .histogram-chart,
        #yearHistogramContainer .histogram-chart {
            margin-top: 0;
            height: 280px;
        }

        .line-chart-line {
            fill: none;
            stroke-width: 3.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
            transition: stroke-width 0.3s;
        }

        .line-chart-line:hover {
            stroke-width: 4.5;
        }

        .line-chart-point {
            fill: white;
            stroke-width: 3;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15));
        }

        .line-chart-point:hover {
            r: 7;
            stroke-width: 4;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
        }

        .line-chart-grid {
            stroke: #cbd5e1;
            stroke-width: 1;
            stroke-dasharray: 3,3;
            opacity: 0.6;
        }

        .line-chart-axis {
            stroke: #64748b;
            stroke-width: 2;
        }

        .line-chart-label {
            font-size: 0.8rem;
            fill: #475569;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .line-chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 2px solid #e2e8f0;
        }

        .line-chart-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            color: #334155;
            padding: 6px 12px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .line-chart-legend-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .line-chart-legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Chart Type Selector */
        .chart-type-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            padding: 4px;
            background: #f1f5f9;
            border-radius: 10px;
            width: fit-content;
        }

        .chart-type-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: #64748b;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .chart-type-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .chart-type-btn:hover:not(.active) {
            background: white;
            color: #334155;
        }

        /* Category Selector for Charts */
        .category-selector-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 12px;
        }

        .category-selector-icon {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 1.3rem;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .category-selector-icon:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .category-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 8px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            padding: 8px;
            z-index: 1000;
            min-width: 160px;
            max-height: 280px;
            overflow-y: auto;
        }

        .category-dropdown.show {
            display: block;
        }

        .category-option {
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 2px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #374151;
        }

        .category-option:hover {
            background: #f3f4f6;
        }

        .category-option.selected {
            background: linear-gradient(135deg, #f0f4ff 0%, #e0e7ff 100%);
            color: #667eea;
            border: 2px solid #667eea;
        }

        /* Column/Bar Chart Styles */
        .column-chart-container {
            position: relative;
            height: 340px;
            padding: 24px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            margin-top: 20px;
            border: 1px solid #e2e8f0;
        }

        .column-chart-svg {
            width: 100%;
            height: 100%;
        }

        .column-group {
            cursor: pointer;
        }

        .column-bar {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            rx: 4;
        }

        .column-bar:hover {
            opacity: 0.8;
            filter: brightness(1.1);
        }

        .column-label {
            font-size: 0.75rem;
            fill: #475569;
            font-weight: 600;
            text-anchor: middle;
        }

        .column-value {
            font-size: 0.7rem;
            fill: #1f2937;
            font-weight: 700;
            text-anchor: middle;
            font-family: 'Courier New', monospace;
        }

        .multi-category-chart {
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .app {
                border-radius: 0;
                min-height: 100vh;
            }

            .app-header {
                padding: 25px 20px;
            }

            .app-header h1 {
                font-size: 1.8rem;
            }

            .app-header p {
                font-size: 0.95rem;
            }

            .time {
                font-size: 2.8rem;
            }

            .tracker-container, .logs-container {
                padding: 20px;
            }

            .categories-grid {
                grid-template-columns: repeat(auto-fill, 85px);
                gap: 8px;
                justify-content: center;
            }

            .category-card {
                padding: 8px 4px 6px;
                width: 85px;
                height: 95px;
                min-width: 85px;
                max-width: 85px;
                min-height: 95px;
                max-height: 95px;
            }

            .category-icon {
                font-size: 1.3rem;
                width: 44px;
                height: 44px;
                min-width: 44px;
                min-height: 44px;
                max-width: 44px;
                max-height: 44px;
                border-radius: 12px;
            }

            .category-name {
                font-size: 0.65rem;
            }

            .category-card-wrapper {
                width: 85px;
            }

            .timer-controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                padding: 15px;
                font-size: 1rem;
            }

            .stats-summary {
                grid-template-columns: 1fr;
            }

            .view-toggle button {
                padding: 12px 8px;
                font-size: 0.9rem;
            }

            .manual-entry {
                padding: 15px;
            }

            .manual-entry h4 {
                font-size: 1rem;
            }

            .manual-row {
                flex-direction: column;
                gap: 10px;
            }

            .category-selector-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .manage-btn {
                width: 100%;
                text-align: center;
            }

            .overview-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .overview-controls {
                width: 100%;
                flex-wrap: wrap;
            }

            .overview-table {
                font-size: 0.8rem;
            }

            .overview-table th,
            .overview-table td {
                padding: 8px 6px;
            }

            .overview-table .cat-badge {
                padding: 3px 8px;
                font-size: 0.75rem;
            }

            .management-content {
                max-height: 95vh;
                border-radius: 12px;
            }

            .management-header h2 {
                font-size: 1.1rem;
            }

            .management-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .management-item-actions {
                width: 100%;
                justify-content: flex-end;
            }

            .subcategory-list {
                margin-left: 10px;
            }

            /* Touch-friendly improvements */
            button, select, input {
                min-height: 44px;
            }

            .category-actions {
                opacity: 1;
            }

            /* Chart mobile styles */
            .chart-container {
                padding: 15px;
            }

            .bar-item {
                flex-direction: column;
                gap: 8px;
            }

            .bar-label {
                min-width: auto;
                width: 100%;
            }

            .bar-container {
                width: 100%;
            }

            .bar-value {
                min-width: auto;
                width: 100%;
                text-align: left;
            }

            .chart-grid {
                grid-template-columns: 1fr;
            }

            .day-comparison {
                grid-template-columns: 1fr;
            }

            .day-card {
                padding: 12px;
            }

            /* Charts row container mobile styles */
            .charts-row-container {
                flex-direction: column;
                gap: 12px;
            }

            .charts-row-container > .chart-container {
                min-width: 100%;
                width: 100%;
            }

            /* Histogram and line chart mobile styles */
            .chart-container {
                padding: 16px;
                margin-bottom: 16px;
            }

            .chart-title {
                font-size: 1rem;
                margin-bottom: 16px;
                padding-bottom: 10px;
            }

            .histogram-chart {
                height: 180px;
                padding: 20px 8px 12px;
            }

            .histogram-bar {
                min-width: 35px;
            }

            .histogram-bar-label {
                font-size: 0.7rem;
            }

            .histogram-bar-value {
                font-size: 0.7rem;
                padding: 3px 6px;
                top: -24px;
            }

            .line-chart-container {
                min-height: 300px;
                padding: 16px;
                overflow: visible;
            }

            .line-chart-svg {
                min-height: 280px;
            }

            .line-chart-legend {
                gap: 12px;
                margin-top: 16px;
                padding-top: 16px;
            }

            .line-chart-legend-item {
                font-size: 0.8rem;
                padding: 4px 8px;
            }

            .line-chart-legend-color {
                width: 14px;
                height: 14px;
            }

            /* Chart type selector mobile */
            .chart-type-selector {
                width: 100%;
                justify-content: center;
            }

            .chart-type-btn {
                flex: 1;
                padding: 10px 12px;
                font-size: 0.85rem;
            }

            /* Column chart mobile */
            .column-chart-container {
                height: 250px;
                padding: 16px;
            }

            /* Category selector mobile */
            .category-selector-wrapper {
                position: relative;
            }

            .category-selector-icon {
                width: 40px;
                height: 40px;
                font-size: 1.1rem;
            }

            .category-dropdown {
                left: auto;
                right: 0;
                min-width: 180px;
                max-height: 250px;
            }

            .category-option {
                padding: 7px 10px;
                font-size: 0.85rem;
                margin-bottom: 1px;
            }
        }

        /* Header buttons */
        .header-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .auth-btn, .sync-btn, .lang-btn {
            padding: 10px 0;
            width: 120px;
            min-width: 120px;
            max-width: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            box-sizing: border-box;
        }

        .auth-btn:hover, .sync-btn:hover, .lang-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: white;
            transform: scale(1.05);
        }

        .auth-btn.logged-in {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.8);
        }

        .sync-status {
            font-size: 0.8rem;
            margin-top: 8px;
            opacity: 0.9;
        }

        /* Auth Modal */
        .auth-modal, .config-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .auth-modal.active, .config-modal.active {
            display: flex;
        }

        .auth-content, .config-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .auth-header, .config-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .auth-header h2, .config-header h2 {
            font-size: 1.2rem;
            margin: 0;
        }

        .auth-close, .config-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .auth-body, .config-body {
            padding: 25px;
            overflow-y: auto;
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #e5e7eb;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            border: none;
            background: #f9fafb;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .auth-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .auth-field {
            margin-bottom: 15px;
        }

        .auth-field label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 6px;
        }

        .auth-field input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .auth-field input:focus {
            outline: none;
            border-color: #667eea;
        }

        .auth-submit-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .auth-submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .auth-divider {
            text-align: center;
            margin: 20px 0;
            position: relative;
        }

        .auth-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #e5e7eb;
        }

        .auth-divider span {
            background: white;
            padding: 0 15px;
            color: #9ca3af;
            font-size: 0.85rem;
            position: relative;
        }

        .google-btn {
            width: 100%;
            padding: 12px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s;
        }

        .google-btn:hover {
            border-color: #4285F4;
            background: #f8fafc;
        }

        .auth-setup-info {
            margin-top: 20px;
            padding: 15px;
            background: #fef3c7;
            border-radius: 10px;
            font-size: 0.85rem;
        }

        .auth-setup-info summary {
            cursor: pointer;
            font-weight: 600;
            color: #92400e;
        }

        .auth-setup-info ol {
            margin: 10px 0 10px 20px;
            color: #78350f;
        }

        .auth-setup-info li {
            margin-bottom: 5px;
        }

        .auth-setup-info a {
            color: #2563eb;
        }

        .config-btn {
            width: 100%;
            margin-top: 10px;
            padding: 10px;
            background: #f59e0b;
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }

        /* Account view */
        .account-info {
            text-align: center;
            padding: 20px 0;
        }

        .account-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            margin: 0 auto 15px;
        }

        .account-email {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 8px;
        }

        .account-sync-status {
            font-size: 0.9rem;
            color: #059669;
            padding: 8px 15px;
            background: #d1fae5;
            border-radius: 20px;
            display: inline-block;
        }

        .account-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .sync-now-btn, .logout-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .sync-now-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .logout-btn {
            background: #fee2e2;
            color: #dc2626;
        }

        .last-sync {
            text-align: center;
            margin-top: 15px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        /* Config modal */
        .config-body textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.85rem;
            margin: 10px 0;
            resize: vertical;
        }

        .save-config-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
        }

        .config-note {
            text-align: center;
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 10px;
        }

        /* Sync button */
        /* Sync button hover is defined above with .auth-btn:hover, .sync-btn:hover */

        /* Sync Modal */
        .sync-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2500;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .sync-modal.active {
            display: flex;
        }

        .sync-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .sync-header {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sync-header h2 {
            font-size: 1.2rem;
            margin: 0;
        }

        .sync-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }

        .sync-body {
            padding: 20px;
            overflow-y: auto;
        }

        .sync-section {
            margin-bottom: 20px;
        }

        .sync-section h3 {
            font-size: 1rem;
            color: #374151;
            margin-bottom: 8px;
        }

        .sync-section p {
            font-size: 0.85rem;
            color: #6b7280;
            margin-bottom: 12px;
        }

        .sync-action-btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .export-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .import-btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
            color: white;
        }

        .import-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .copy-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        .paste-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .paste-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .sync-divider {
            text-align: center;
            margin: 25px 0;
            position: relative;
        }

        .sync-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #e5e7eb;
        }

        .sync-divider span {
            background: white;
            padding: 0 15px;
            color: #9ca3af;
            font-size: 0.85rem;
            position: relative;
        }

        .sync-code-display {
            margin-top: 10px;
            padding: 10px;
            background: #d1fae5;
            border-radius: 8px;
            color: #059669;
            font-size: 0.85rem;
            text-align: center;
        }

        .sync-code-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 0.9rem;
            font-family: monospace;
            resize: none;
            margin-bottom: 10px;
        }

        .sync-code-input:focus {
            outline: none;
            border-color: #10b981;
        }

        .sync-info {
            margin-top: 20px;
            padding: 15px;
            background: #f0f9ff;
            border-radius: 10px;
            border-left: 4px solid #0ea5e9;
        }

        .sync-info p {
            margin: 0;
            font-size: 0.85rem;
            color: #0369a1;
        }

        /* Language Options */
        .language-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .language-option {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            text-align: left;
        }

        .language-option:hover {
            border-color: #667eea;
            background: #f8fafc;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.2);
        }

        .language-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #e0e7ff 0%, #f3f4f6 100%);
        }

        .lang-flag {
            font-size: 2rem;
            line-height: 1;
        }

        .lang-name {
            flex: 1;
            font-size: 1rem;
            font-weight: 600;
            color: #1f2937;
        }

        .lang-check {
            font-size: 1.2rem;
            color: #667eea;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .language-option.selected .lang-check {
            opacity: 1;
        }

        /* Install button */
        .install-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 25px;
            color: #667eea;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .install-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        /* Safe area padding for notched phones */
        @supports (padding: max(0px)) {
            body {
                padding-left: max(env(safe-area-inset-left), 0px);
                padding-right: max(env(safe-area-inset-right), 0px);
                padding-bottom: max(env(safe-area-inset-bottom), 0px);
            }
        }

        /* Prevent text selection on buttons for touch */
        button {
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>⏳ Hourglass</h1>
            <p class="slogan">Watch time pass, choose how to live.</p>
            <div class="header-buttons">
                <button id="authBtn" class="auth-btn" onclick="openAuthModal()">👤 Login</button>
                <button class="sync-btn" onclick="openSyncModal()">🔄 Sync</button>
                <button class="lang-btn" onclick="openLanguageModal()">🌐 Language</button>
            </div>
            <div id="syncStatus" class="sync-status"></div>
        </header>

        <div class="view-toggle">
            <button id="trackerBtn" class="active" onclick="switchView('tracker')">Timer</button>
            <button id="logsBtn" onclick="switchView('logs')">Logs & Stats</button>
        </div>

        <!-- Tracker View -->
        <div id="trackerView" class="tracker-container">
            <div class="timer-display">
                <div class="time" id="timeDisplay">00:00:00</div>
                <div class="timer-controls">
                    <button id="startBtn" class="btn btn-start" onclick="startTimer()">▶ Start</button>
                    <button id="stopBtn" class="btn btn-stop hidden" onclick="stopTimer()">⏹ Stop & Save</button>
                    <button id="resetBtn" class="btn btn-reset hidden" onclick="resetTimer()">↻ Reset</button>
                </div>
            </div>

            <div class="category-selector">
                <div class="category-selector-header">
                    <h3>Select Category</h3>
                    <button class="manage-btn" onclick="openManagementModal()">⚙️ Manage</button>
                </div>
                <div class="categories-grid" id="categoriesGrid"></div>
            </div>

            <!-- Goals Section -->
            <div class="goals-section">
                <div class="goals-header">
                    <h3>📋 Plan and Goals</h3>
                    <button class="btn-goal-add" onclick="openAddGoalModal()">➕ Add Goal</button>
                </div>

                <div class="goals-display" id="goalsDisplay">
                    <!-- Goals progress will be rendered here -->
                </div>
            </div>

            <div id="activeTimerInfo" class="active-timer-info hidden">
                <p>Tracking: <strong id="activeCategoryName"></strong></p>
            </div>

            <div class="manual-entry-section">
                <h3>📝 Manual Entry (Add Record Without Timer)</h3>
                <div class="manual-entry-form">
                    <div class="form-group" style="grid-column: 1 / -1;">
                        <label for="manualCategory">Category</label>
                        <select id="manualCategory" onchange="updateManualSubcategoryDropdown()" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 0.95rem;">
                            <!-- Categories will be populated by JavaScript -->
                        </select>
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1;">
                        <label for="manualSubcategory">Subcategory (optional)</label>
                        <select id="manualSubcategory" onchange="handleManualSubcategoryChange()" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 0.95rem;">
                            <option value="">-- No subcategory --</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="manualStartTime">Start time</label>
                        <div class="time-input-group">
                            <select id="manualStartHour" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 0.95rem;"></select>
                            <span>:</span>
                            <select id="manualStartMinute" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 0.95rem;"></select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="manualEndTime">End time</label>
                        <div class="time-input-group">
                            <select id="manualEndHour" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 0.95rem;"></select>
                            <span>:</span>
                            <select id="manualEndMinute" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 0.95rem;"></select>
                        </div>
                    </div>
                </div>
                <button class="btn btn-add" onclick="addManualEntry()" style="width: 100%; margin-top: 10px; padding: 12px;">
                    ➕ Add Record
                </button>
            </div>

            <!-- Add/Edit Goal Modal -->
            <div id="goalModal" class="goal-modal hidden" onclick="closeGoalModal(event)">
                <div class="goal-modal-content" onclick="event.stopPropagation()">
                    <div class="goal-modal-header">
                        <h3 id="goalModalTitle">Add New Goal</h3>
                        <button class="close-modal" onclick="closeGoalModal()">✕</button>
                    </div>
                    <div class="goal-modal-body">
                        <div class="goal-input-group">
                            <label for="goalName">Goal Name</label>
                            <input type="text" id="goalName" placeholder="e.g., Learn Spanish, Exercise Daily" maxlength="50" />
                        </div>
                        <div class="goal-input-group">
                            <label for="goalCategory">Category *</label>
                            <select id="goalCategory" onchange="updateGoalSubcategoryDropdown()" style="width: 100%; padding: 10px; border: 2px solid #bfdbfe; border-radius: 6px; font-size: 0.95rem;">
                                <!-- Categories will be populated by JavaScript -->
                            </select>
                            <div style="font-size: 0.85rem; color: #6b7280; margin-top: 5px;">
                                Only time logged in this category will count toward this goal
                            </div>
                        </div>
                        <div class="goal-input-group">
                            <label for="goalSubcategory">Subcategory (optional)</label>
                            <select id="goalSubcategory" style="width: 100%; padding: 10px; border: 2px solid #bfdbfe; border-radius: 6px; font-size: 0.95rem;">
                                <option value="">-- All subcategories --</option>
                            </select>
                            <div style="font-size: 0.85rem; color: #6b7280; margin-top: 5px;">
                                If selected, only this subcategory will count. Leave blank to count all subcategories.
                            </div>
                        </div>
                        <div class="goal-input-group">
                            <label for="goalPeriod">Time Period</label>
                            <select id="goalPeriod" style="width: 100%; padding: 10px; border: 2px solid #bfdbfe; border-radius: 6px; font-size: 0.95rem;">
                                <option value="day">Day</option>
                                <option value="week">Week</option>
                                <option value="month">Month</option>
                                <option value="year">Year</option>
                            </select>
                        </div>
                        <div class="goal-input-group">
                            <label for="goalTarget">Target Time (hours)</label>
                            <input type="number" id="goalTarget" min="0" step="0.5" placeholder="0.0" />
                        </div>
                        <div class="goal-input-group">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                                <input type="checkbox" id="goalRepeat" style="width: 20px; height: 20px; cursor: pointer;" />
                                <span>Repeat this goal periodically</span>
                            </label>
                            <div style="font-size: 0.85rem; color: #6b7280; margin-top: 5px; margin-left: 30px;">
                                If enabled, this goal will reset and track progress for each new period
                            </div>
                        </div>
                    </div>
                    <div class="goal-modal-actions">
                        <button class="btn btn-save" onclick="saveGoal()">💾 Save</button>
                        <button class="btn btn-cancel" onclick="closeGoalModal()">❌ Cancel</button>
                        <button class="btn btn-delete hidden" id="goalDeleteBtn" onclick="deleteGoal()">🗑️ Delete</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Logs View -->
        <div id="logsView" class="logs-container hidden">
            <!-- Stats Header with Date and View Selector -->
            <div class="overview-header" style="margin-bottom: 20px;">
                <h3>📈 Statistics</h3>
                <div class="overview-controls">
                    <label for="statsDate">Date</label>
                    <input id="statsDate" type="date" onchange="updateLogsView()" />
                    <label for="statsRange">View</label>
                    <select id="statsRange" onchange="updateLogsView()" style="padding: 8px 12px; border-radius: 8px; border: 2px solid #e5e7eb; font-size: 0.95rem; background: white;">
                        <option value="day">Day</option>
                        <option value="week">Week</option>
                        <option value="month">Month</option>
                        <option value="year">Year</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
            </div>

            <div class="category-stats">
                <h3>Time by Category</h3>
                <div class="category-bars" id="categoryBars"></div>
            </div>

            <!-- Overview Section (integrated) -->
            <div class="overview-section">
                <div class="overview-header">
                    <h3>📊 Overview</h3>
                </div>
                <div class="timeline">
                    <div id="timelineGrid" class="timeline-grid"></div>
                </div>
                <div id="overviewSummary" class="logs-list" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>

    <!-- Modal for Category Details -->
    <div id="categoryModal" class="modal-overlay hidden" onclick="closeCategoryModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 id="categoryModalTitle">Category Details</h3>
                <button class="close-modal" onclick="closeCategoryModal()">✕</button>
            </div>
            <div id="categoryModalBody">
                <!-- Logs will be populated by JS -->
            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="auth-modal" onclick="closeAuthModal(event)">
        <div class="auth-content" onclick="event.stopPropagation()">
            <div class="auth-header">
                <h2 id="authTitle">👤 Login / Sign Up</h2>
                <button class="auth-close" onclick="closeAuthModal()">&times;</button>
            </div>
            <div class="auth-body">
                <!-- Not logged in view -->
                <div id="authLoginView">
                    <div class="auth-tabs">
                        <button class="auth-tab active" onclick="switchAuthTab('login')">Login</button>
                        <button class="auth-tab" onclick="switchAuthTab('signup')">Sign Up</button>
                    </div>
                    
                    <form id="authForm" onsubmit="handleAuthSubmit(event)">
                        <div class="auth-field">
                            <label>Email</label>
                            <input type="email" id="authEmail" required placeholder="your@email.com">
                        </div>
                        <div class="auth-field">
                            <label>Password</label>
                            <input type="password" id="authPassword" required placeholder="••••••••" minlength="6">
                        </div>
                        <button type="submit" class="auth-submit-btn" id="authSubmitBtn">Login</button>
                    </form>

                    <div class="auth-divider"><span>or</span></div>

                    <button class="google-btn" onclick="signInWithGoogle()">
                        <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/><path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/><path fill="#FBBC05" d="M3.964 10.71c-.18-.54-.282-1.117-.282-1.71s.102-1.17.282-1.71V4.958H.957C.347 6.173 0 7.548 0 9s.348 2.827.957 4.042l3.007-2.332z"/><path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z"/></svg>
                        Continue with Google
                    </button>

                    <div class="auth-setup-info">
                        <details>
                            <summary>⚙️ First time? Set up Firebase (one-time)</summary>
                            <ol>
                                <li>Go to <a href="https://console.firebase.google.com" target="_blank">Firebase Console</a></li>
                                <li>Create a new project (free)</li>
                                <li>Enable Authentication → Email/Password & Google</li>
                                <li>Create Firestore Database</li>
                                <li>Get your config from Project Settings</li>
                                <li>Click "Configure Firebase" below</li>
                            </ol>
                            <button class="config-btn" onclick="showFirebaseConfig()">🔧 Configure Firebase</button>
                        </details>
                    </div>
                </div>

                <!-- Logged in view -->
                <div id="authAccountView" style="display:none;">
                    <div class="account-info">
                        <div class="account-avatar" id="accountAvatar">👤</div>
                        <div class="account-email" id="accountEmail">user@email.com</div>
                        <div class="account-sync-status" id="accountSyncStatus">
                            ✅ Auto-sync enabled
                        </div>
                    </div>
                    <div class="account-actions">
                        <button class="sync-now-btn" onclick="syncToCloud()">🔄 Sync Now</button>
                        <button class="logout-btn" onclick="logoutUser()">🚪 Logout</button>
                    </div>
                    <div class="last-sync" id="lastSyncTime">Last synced: Never</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase Config Modal -->
    <div id="firebaseConfigModal" class="config-modal" onclick="closeFirebaseConfig(event)">
        <div class="config-content" onclick="event.stopPropagation()">
            <div class="config-header">
                <h2>🔧 Firebase Configuration</h2>
                <button class="config-close" onclick="closeFirebaseConfig()">&times;</button>
            </div>
            <div class="config-body">
                <p>Paste your Firebase config object here:</p>
                <textarea id="firebaseConfigInput" rows="10" placeholder='{
  "apiKey": "your-api-key",
  "authDomain": "your-project.firebaseapp.com",
  "projectId": "your-project-id",
  "storageBucket": "your-project.appspot.com",
  "messagingSenderId": "123456789",
  "appId": "your-app-id"
}'></textarea>
                <button class="save-config-btn" onclick="saveFirebaseConfig()">💾 Save Configuration</button>
                <p class="config-note">Your config is stored locally and never shared.</p>
            </div>
        </div>
    </div>

    <!-- Sync Modal -->
    <div id="syncModal" class="sync-modal" onclick="closeSyncModal(event)">
        <div class="sync-content" onclick="event.stopPropagation()">
            <div class="sync-header">
                <h2>🔄 Sync Data Across Devices</h2>
                <button class="sync-close" onclick="closeSyncModal()">&times;</button>
            </div>
            <div class="sync-body">
                <div class="sync-section">
                    <h3>📤 Export Data</h3>
                    <p>Download all your data as a file. You can then import it on another device.</p>
                    <button class="sync-action-btn export-btn" onclick="exportData()">
                        📥 Download Data File
                    </button>
                </div>

                <div class="sync-section">
                    <h3>📥 Import Data</h3>
                    <p>Upload a data file from another device to sync your records.</p>
                    <input type="file" id="importFile" accept=".json" style="display:none" onchange="importData(event)">
                    <button class="sync-action-btn import-btn" onclick="document.getElementById('importFile').click()">
                        📤 Upload Data File
                    </button>
                </div>

                <div class="sync-divider">
                    <span>OR Quick Sync</span>
                </div>

                <div class="sync-section">
                    <h3>📋 Copy Sync Code</h3>
                    <p>Copy this code and paste it on your other device.</p>
                    <button class="sync-action-btn copy-btn" onclick="copySyncCode()">
                        📋 Copy Sync Code
                    </button>
                    <div id="syncCodeDisplay" class="sync-code-display" style="display:none;">
                        <small>Code copied! Valid for import on another device.</small>
                    </div>
                </div>

                <div class="sync-section">
                    <h3>📝 Paste Sync Code</h3>
                    <p>Paste a sync code from another device to import data.</p>
                    <textarea id="syncCodeInput" class="sync-code-input" placeholder="Paste sync code here..." rows="3"></textarea>
                    <button class="sync-action-btn paste-btn" onclick="importSyncCode()">
                        ✅ Import from Code
                    </button>
                </div>

                <div class="sync-info">
                    <p>💡 <strong>Tip:</strong> For automatic sync, consider using cloud storage services like Google Drive or Dropbox to store your exported data file.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Language Modal -->
    <div id="languageModal" class="sync-modal" onclick="closeLanguageModal(event)">
        <div class="sync-content" onclick="event.stopPropagation()">
            <div class="sync-header">
                <h2>🌐 Choose Language</h2>
                <button class="sync-close" onclick="closeLanguageModal()">&times;</button>
            </div>
            <div class="sync-body">
                <div class="sync-section">
                    <div class="language-options">
                        <button class="language-option" onclick="setLanguage('en')" id="lang-en">
                            <span class="lang-flag">🇺🇸</span>
                            <span class="lang-name">English</span>
                            <span class="lang-check" id="check-en">✓</span>
                        </button>
                        <button class="language-option" onclick="setLanguage('zh')" id="lang-zh">
                            <span class="lang-flag">🇨🇳</span>
                            <span class="lang-name">中文 (Chinese)</span>
                            <span class="lang-check" id="check-zh">✓</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Management Modal -->
    <div id="managementModal" class="management-modal" onclick="closeManagementModal(event)">
        <div class="management-content" onclick="event.stopPropagation()">
            <div class="management-header">
                <h2>⚙️ Manage Categories & Subcategories</h2>
                <button class="management-close" onclick="closeManagementModal()">&times;</button>
            </div>
            <div class="management-body" id="managementBody">
                <!-- Content populated by JS -->
            </div>
        </div>
    </div>

    <script>
        const DEFAULT_CATEGORIES = [
            { id: 'work', name: 'Working', color: '#3b82f6', icon: '💼', isCustom: false, subcategories: ['Full-time job', 'Part-time job', 'Freelance', 'Meeting'] },
            { id: 'learning', name: 'Learning', color: '#10b981', icon: '📚', isCustom: false, subcategories: ['Academic learning', 'Skill training', 'Online course', 'Language study'] },
            { id: 'reading', name: 'Reading', color: '#6366f1', icon: '📖', isCustom: false, subcategories: ['Books', 'Articles', 'News', 'Research'] },
            { id: 'sports', name: 'Sports', color: '#f59e0b', icon: '🏃', isCustom: false, subcategories: ['Running', 'Gym', 'Swimming', 'Cycling', 'Yoga'] },
            { id: 'daily', name: 'Daily Routine', color: '#ec4899', icon: '🌅', isCustom: false, subcategories: ['Morning routine', 'Meals', 'Commute', 'Personal care', 'Errands'] },
            { id: 'housework', name: 'Housework', color: '#14b8a6', icon: '🏠', isCustom: false, subcategories: ['Cleaning', 'Cooking', 'Laundry', 'Shopping'] },
            { id: 'entertainment', name: 'Entertainment', color: '#ef4444', icon: '🎮', isCustom: false, subcategories: ['Gaming', 'Movies', 'Music', 'Social media'] },
            { id: 'social', name: 'Social', color: '#8b5cf6', icon: '👥', isCustom: false, subcategories: ['Family', 'Friends', 'Dating', 'Networking'] },
            { id: 'rest', name: 'Rest', color: '#06b6d4', icon: '😴', isCustom: false, subcategories: ['Sleep', 'Nap', 'Relaxation', 'Meditation'] },
        ];

        let customCategories = [];
        let customSubcategories = {}; // { categoryId: ['custom sub 1', 'custom sub 2'] }
        let modifiedDefaults = {}; // { categoryId: { name: 'New Name', ... } }
        let deletedDefaults = []; // ['work', 'learning', ...]
        let activeTimer = null;
        let elapsedTime = 0;
        let timeLogs = [];
        let selectedCategory = 'work';
        let selectedSubcategory = null;
        let timerInterval = null;
        let goals = []; // Array of goal objects: { id, name, period, target }
        let currentLanguage = 'en'; // Default language

        // Translation strings
        const translations = {
            en: {
                // Header
                login: 'Login',
                sync: 'Sync',
                language: 'Language',
                // Timer
                start: 'Start',
                stop: 'Stop & Save',
                reset: 'Reset',
                selectCategory: 'Select Category',
                manage: 'Manage',
                tracking: 'Tracking',
                // Manual Entry
                manualEntry: 'Manual Entry (Add Record Without Timer)',
                category: 'Category',
                subcategory: 'Subcategory (optional)',
                startTime: 'Start time',
                endTime: 'End time',
                addRecord: 'Add Record',
                noSubcategory: '-- No subcategory --',
                // Goals
                planAndGoals: 'Plan and Goals',
                addGoal: 'Add Goal',
                addNewGoal: 'Add New Goal',
                editGoal: 'Edit Goal',
                goalName: 'Goal Name',
                goalNamePlaceholder: 'e.g., Learn Spanish, Exercise Daily',
                timePeriod: 'Time Period',
                targetTime: 'Target Time (hours)',
                repeatGoal: 'Repeat this goal periodically',
                repeatGoalDesc: 'If enabled, this goal will reset and track progress for each new period',
                save: 'Save',
                cancel: 'Cancel',
                delete: 'Delete',
                noGoalsSet: 'No goals set. Click "Add Goal" to create your first goal!',
                goalAchieved: 'Goal Achieved!',
                almostThere: 'Almost there!',
                remaining: 'remaining',
                repeatsEachPeriod: '(repeats each period)',
                today: 'Today',
                thisWeek: 'This Week',
                thisMonth: 'This Month',
                thisYear: 'This Year',
                allSubcategories: '-- All subcategories --',
                onlyTimeLogged: 'Only time logged in this category will count toward this goal',
                ifSelectedOnly: 'If selected, only this subcategory will count. Leave blank to count all subcategories.',
                // Logs & Stats
                statistics: 'Statistics',
                timeByCategory: 'Time by Category',
                overview: 'Overview',
                date: 'Date',
                view: 'View',
                totalTimeByCategory: 'Total Time by Category',
                categoryTrendsByDay: 'Category Trends by Day',
                categoryTrendsByWeek: 'Category Trends by Week',
                categoryTrendsByMonth: 'Category Trends by Month',
                noRecordsForRange: 'No records for this range.',
                // Common
                day: 'Day',
                week: 'Week',
                month: 'Month',
                year: 'Year',
                allTime: 'All Time',
                // Language Modal
                chooseLanguage: 'Choose Language',
                // Modals
                loginSignUp: 'Login / Sign Up',
                email: 'Email',
                password: 'Password',
                forgotPassword: 'Forgot Password?',
                signUp: 'Sign Up',
                alreadyHaveAccount: 'Already have an account?',
                dontHaveAccount: "Don't have an account?",
                loginWithGoogle: 'Login with Google',
                logout: 'Logout',
                syncDataAcrossDevices: 'Sync Data Across Devices',
                exportData: 'Export Data',
                exportDataDesc: 'Download all your data as a file. You can then import it on another device.',
                downloadDataFile: 'Download Data File',
                importData: 'Import Data',
                importDataDesc: 'Upload a data file from another device to sync your records.',
                uploadDataFile: 'Upload Data File',
                orQuickSync: 'OR Quick Sync',
                copySyncCode: 'Copy Sync Code',
                copySyncCodeDesc: 'Copy this code and paste it on your other device.',
                codeCopied: 'Code copied! Valid for import on another device.',
                pasteSyncCode: 'Paste Sync Code',
                pasteSyncCodeDesc: 'Paste a sync code from another device to import data.',
                pasteSyncCodePlaceholder: 'Paste sync code here...',
                importFromCode: 'Import from Code',
                syncTip: 'Tip: For automatic sync, consider using cloud storage services like Google Drive or Dropbox to store your exported data file.',
                manageCategories: 'Manage Categories & Subcategories',
                // Management Modal
                categories: 'Categories',
                addCategory: 'Add Category',
                editCategory: 'Edit Category',
                deleteCategory: 'Delete Category',
                subcategories: 'Subcategories',
                addSubcategory: 'Add Subcategory',
                editSubcategory: 'Edit Subcategory',
                deleteSubcategory: 'Delete Subcategory',
                resetToDefaults: 'Reset to Defaults',
                categoryName: 'Category Name',
                subcategoryName: 'Subcategory Name',
                // Category Details Modal
                categoryDetails: 'Category Details',
                startTime: 'Start Time',
                endTime: 'End Time',
                duration: 'Duration',
                saveChanges: 'Save Changes',
                deleteLog: 'Delete',
                deleteLogConfirm: 'Delete this log entry?',
                // Alerts and Messages
                pleaseEnterGoalName: 'Please enter a goal name',
                pleaseSelectCategory: 'Please select a category',
                pleaseEnterValidTarget: 'Please enter a valid target time (greater than 0)',
                pleaseSelectStartEndTime: 'Please select start and end time',
                pleaseSelectCategoryForEntry: 'Please select a category',
                invalidCategory: 'Invalid category selected',
                deleteGoalConfirm: 'Are you sure you want to delete this goal?',
                deleteCategoryConfirm: 'Delete category',
                deleteSubcategoryConfirm: 'Delete subcategory',
                // Firebase Config
                firebaseConfiguration: 'Firebase Configuration',
                apiKey: 'API Key',
                authDomain: 'Auth Domain',
                projectId: 'Project ID',
                storageBucket: 'Storage Bucket',
                messagingSenderId: 'Messaging Sender ID',
                appId: 'App ID',
                saveConfiguration: 'Save Configuration',
                // View Toggle
                timer: 'Timer',
                logsStats: 'Logs & Stats',
                // Additional alerts
                resetToDefaultsConfirm: 'Reset all categories and subcategories to defaults? This will:\n- Restore deleted default categories\n- Restore deleted default subcategories\n- Revert name changes to default categories\n- Keep your custom categories and subcategories\n- Keep your time logs\n\nContinue?',
                resetToDefaultsSuccess: 'Default categories and subcategories have been restored!',
                subcategoryExists: 'A subcategory with this name already exists.',
                deleteSubcategoryConfirm: 'Delete subcategory "{name}"? This will remove it from the list but existing logs will keep this subcategory.',
                subcategoryExistsInvalid: 'Subcategory already exists or is invalid.',
                cannotAddCategoryWhileTimer: 'Cannot add category while timer is running',
                categoryExists: 'A category with this name already exists',
                pleaseEnsureEndAfterStart: 'Please ensure end time is after start time',
                deleteCategoryConfirmMsg: 'Delete category "{name}"?',
                deleteSubcategoryConfirmMsg: 'Delete subcategory "{name}"?'
            },
            zh: {
                // Header
                login: '登录',
                sync: '同步',
                language: '语言',
                // Timer
                start: '开始',
                stop: '停止并保存',
                reset: '重置',
                selectCategory: '选择分类',
                manage: '管理',
                tracking: '正在追踪',
                // Manual Entry
                manualEntry: '手动录入（不使用计时器添加记录）',
                category: '分类',
                subcategory: '子分类（可选）',
                startTime: '开始时间',
                endTime: '结束时间',
                addRecord: '添加记录',
                noSubcategory: '-- 无子分类 --',
                // Goals
                planAndGoals: '计划与目标',
                addGoal: '添加目标',
                addNewGoal: '添加新目标',
                editGoal: '编辑目标',
                goalName: '目标名称',
                goalNamePlaceholder: '例如：学习西班牙语，每日运动',
                timePeriod: '时间周期',
                targetTime: '目标时间（小时）',
                repeatGoal: '定期重复此目标',
                repeatGoalDesc: '如果启用，此目标将在每个新周期重置并跟踪进度',
                save: '保存',
                cancel: '取消',
                delete: '删除',
                noGoalsSet: '未设置目标。点击"添加目标"创建您的第一个目标！',
                goalAchieved: '目标已达成！',
                almostThere: '快完成了！',
                remaining: '剩余',
                repeatsEachPeriod: '（每个周期重复）',
                today: '今天',
                thisWeek: '本周',
                thisMonth: '本月',
                thisYear: '今年',
                allSubcategories: '-- 所有子分类 --',
                onlyTimeLogged: '只有在此分类中记录的时间才会计入此目标',
                ifSelectedOnly: '如果选择，只有此子分类会被计入。留空则计入所有子分类。',
                // Logs & Stats
                statistics: '统计',
                timeByCategory: '按分类时间',
                overview: '概览',
                date: '日期',
                view: '视图',
                totalTimeByCategory: '按分类总时间',
                categoryTrendsByDay: '按日分类趋势',
                categoryTrendsByWeek: '按周分类趋势',
                categoryTrendsByMonth: '按月分类趋势',
                noRecordsForRange: '此范围内无记录。',
                // Common
                day: '日',
                week: '周',
                month: '月',
                year: '年',
                allTime: '全部时间',
                // Language Modal
                chooseLanguage: '选择语言',
                // Modals
                loginSignUp: '登录 / 注册',
                email: '邮箱',
                password: '密码',
                forgotPassword: '忘记密码？',
                signUp: '注册',
                alreadyHaveAccount: '已有账户？',
                dontHaveAccount: '还没有账户？',
                loginWithGoogle: '使用 Google 登录',
                logout: '退出登录',
                syncDataAcrossDevices: '跨设备同步数据',
                exportData: '导出数据',
                exportDataDesc: '将所有数据下载为文件。然后您可以在另一台设备上导入它。',
                downloadDataFile: '下载数据文件',
                importData: '导入数据',
                importDataDesc: '从另一台设备上传数据文件以同步您的记录。',
                uploadDataFile: '上传数据文件',
                orQuickSync: '或快速同步',
                copySyncCode: '复制同步代码',
                copySyncCodeDesc: '复制此代码并粘贴到您的其他设备上。',
                codeCopied: '代码已复制！可在另一台设备上导入。',
                pasteSyncCode: '粘贴同步代码',
                pasteSyncCodeDesc: '粘贴来自另一台设备的同步代码以导入数据。',
                pasteSyncCodePlaceholder: '在此粘贴同步代码...',
                importFromCode: '从代码导入',
                syncTip: '提示：要实现自动同步，可以考虑使用 Google Drive 或 Dropbox 等云存储服务来存储导出的数据文件。',
                manageCategories: '管理分类和子分类',
                // Management Modal
                categories: '分类',
                addCategory: '添加分类',
                editCategory: '编辑分类',
                deleteCategory: '删除分类',
                subcategories: '子分类',
                addSubcategory: '添加子分类',
                editSubcategory: '编辑子分类',
                deleteSubcategory: '删除子分类',
                resetToDefaults: '重置为默认值',
                categoryName: '分类名称',
                subcategoryName: '子分类名称',
                // Category Details Modal
                categoryDetails: '分类详情',
                startTime: '开始时间',
                endTime: '结束时间',
                duration: '持续时间',
                saveChanges: '保存更改',
                deleteLog: '删除',
                deleteLogConfirm: '删除此日志条目？',
                // Alerts and Messages
                pleaseEnterGoalName: '请输入目标名称',
                pleaseSelectCategory: '请选择分类',
                pleaseEnterValidTarget: '请输入有效的目标时间（大于0）',
                pleaseSelectStartEndTime: '请选择开始和结束时间',
                pleaseSelectCategoryForEntry: '请选择分类',
                invalidCategory: '选择的分类无效',
                deleteGoalConfirm: '您确定要删除此目标吗？',
                deleteCategoryConfirm: '删除分类',
                deleteSubcategoryConfirm: '删除子分类',
                // Firebase Config
                firebaseConfiguration: 'Firebase 配置',
                apiKey: 'API 密钥',
                authDomain: '认证域名',
                projectId: '项目 ID',
                storageBucket: '存储桶',
                messagingSenderId: '消息发送者 ID',
                appId: '应用 ID',
                saveConfiguration: '保存配置',
                // View Toggle
                timer: '计时器',
                logsStats: '日志与统计',
                // Additional alerts
                resetToDefaultsConfirm: '将所有分类和子分类重置为默认值？这将：\n- 恢复已删除的默认分类\n- 恢复已删除的默认子分类\n- 恢复默认分类的名称更改\n- 保留您的自定义分类和子分类\n- 保留您的时间日志\n\n继续？',
                resetToDefaultsSuccess: '默认分类和子分类已恢复！',
                subcategoryExists: '已存在同名的子分类。',
                deleteSubcategoryConfirm: '删除子分类"{name}"？这将从列表中删除它，但现有日志将保留此子分类。',
                subcategoryExistsInvalid: '子分类已存在或无效。',
                cannotAddCategoryWhileTimer: '计时器运行时无法添加分类',
                categoryExists: '已存在同名的分类',
                pleaseEnsureEndAfterStart: '请确保结束时间在开始时间之后',
                deleteCategoryConfirmMsg: '删除分类"{name}"？',
                deleteSubcategoryConfirmMsg: '删除子分类"{name}"？'
            }
        };

        // Helper function to get translation
        function t(key) {
            return translations[currentLanguage]?.[key] || translations['en'][key] || key;
        }

        // Get all categories (default + custom), applying modifications and excluding deleted
        function getAllCategories() {
            const defaults = DEFAULT_CATEGORIES
                .filter(c => !deletedDefaults.includes(c.id))
                .map(c => {
                    if (modifiedDefaults[c.id]) {
                        return { ...c, ...modifiedDefaults[c.id] };
                    }
                    return c;
                });
            return [...defaults, ...customCategories];
        }

        // Load modified defaults from localStorage
        function loadModifiedDefaults() {
            const saved = localStorage.getItem('modifiedDefaults');
            if (saved) {
                modifiedDefaults = JSON.parse(saved);
            }
        }

        // Save modified defaults to localStorage
        function saveModifiedDefaults() {
            localStorage.setItem('modifiedDefaults', JSON.stringify(modifiedDefaults));
        }

        // Load deleted defaults from localStorage
        function loadDeletedDefaults() {
            const saved = localStorage.getItem('deletedDefaults');
            if (saved) {
                deletedDefaults = JSON.parse(saved);
            }
        }

        // Save deleted defaults to localStorage
        function saveDeletedDefaults() {
            localStorage.setItem('deletedDefaults', JSON.stringify(deletedDefaults));
        }

        // Reset all categories to defaults
        function resetToDefaults() {
            if (!confirm(t('resetToDefaultsConfirm'))) {
                return;
            }
            modifiedDefaults = {};
            deletedDefaults = [];
            saveModifiedDefaults();
            saveDeletedDefaults();
            
            // Clear hidden subcategories
            localStorage.removeItem('hiddenSubcategories');
            
            // Reset selected category if it was deleted
            const allCats = getAllCategories();
            if (!allCats.find(c => c.id === selectedCategory)) {
                selectedCategory = allCats[0]?.id || 'work';
            }
            
            renderCategories();
            updateManualCategoryDropdown();
            alert(t('resetToDefaultsSuccess'));
        }

        // Get all subcategories for a category (predefined + custom)
        function getAllSubcategories(categoryId) {
            const category = getAllCategories().find(c => c.id === categoryId);
            const allPredefined = category?.subcategories || [];
            const hiddenSubs = JSON.parse(localStorage.getItem('hiddenSubcategories') || '{}');
            const hidden = hiddenSubs[categoryId] || [];
            const predefined = allPredefined.filter(sub => !hidden.includes(sub));
            const custom = customSubcategories[categoryId] || [];
            return [...predefined, ...custom];
        }

        // Load custom subcategories from localStorage
        function loadCustomSubcategories() {
            const saved = localStorage.getItem('customSubcategories');
            if (saved) {
                customSubcategories = JSON.parse(saved);
            }
        }

        // Save custom subcategories to localStorage
        function saveCustomSubcategories() {
            localStorage.setItem('customSubcategories', JSON.stringify(customSubcategories));
        }

        // Add custom subcategory
        function addCustomSubcategory(categoryId, subName) {
            if (!customSubcategories[categoryId]) {
                customSubcategories[categoryId] = [];
            }
            const trimmed = subName.trim();
            if (trimmed && !customSubcategories[categoryId].includes(trimmed)) {
                // Also check if it's not in predefined
                const category = getAllCategories().find(c => c.id === categoryId);
                const predefined = category?.subcategories || [];
                if (!predefined.includes(trimmed)) {
                    customSubcategories[categoryId].push(trimmed);
                    saveCustomSubcategories();
                    return true;
                }
            }
            return false;
        }

        // Edit custom subcategory
        function editCustomSubcategory(categoryId, oldName) {
            const newName = prompt('Edit subcategory name:', oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                // Check if new name already exists
                const allSubs = getAllSubcategories(categoryId);
                if (allSubs.includes(trimmed)) {
                    alert('A subcategory with this name already exists.');
                    return;
                }
                
                // Update in customSubcategories
                if (customSubcategories[categoryId]) {
                    const idx = customSubcategories[categoryId].indexOf(oldName);
                    if (idx !== -1) {
                        customSubcategories[categoryId][idx] = trimmed;
                        saveCustomSubcategories();
                        
                        // Update in existing logs
                        timeLogs.forEach(log => {
                            if (log.category === categoryId && log.subcategory === oldName) {
                                log.subcategory = trimmed;
                            }
                        });
                        saveLogs();
                        
                        // Update selected subcategory if it was the one being edited
                        if (selectedSubcategory === oldName) {
                            selectedSubcategory = trimmed;
                        }
                        
                        renderCategories();
                        updateManualCategoryDropdown();
                    }
                }
            }
        }

        // Delete custom subcategory
        function deleteCustomSubcategory(categoryId, subName) {
            if (!confirm(`Delete subcategory "${subName}"? This will remove it from the list but existing logs will keep this subcategory.`)) {
                return;
            }
            
            if (customSubcategories[categoryId]) {
                customSubcategories[categoryId] = customSubcategories[categoryId].filter(s => s !== subName);
                saveCustomSubcategories();
                
                // Reset selected subcategory if it was the one being deleted
                if (selectedSubcategory === subName) {
                    selectedSubcategory = null;
                }
                
                renderCategories();
                updateManualCategoryDropdown();
            }
        }

        // Check if subcategory is custom (not predefined)
        function isCustomSubcategory(categoryId, subName) {
            return customSubcategories[categoryId]?.includes(subName) || false;
        }

        // Initialize
        function init() {
            loadCustomCategories();
            loadCustomSubcategories();
            loadModifiedDefaults();
            loadDeletedDefaults();
            loadLogs();
            loadGoals();
            loadLanguage();
            
            // Ensure selected category exists
            const allCats = getAllCategories();
            if (!allCats.find(c => c.id === selectedCategory)) {
                selectedCategory = allCats[0]?.id || 'work';
            }
            
            renderCategories();
            updateLogsView();
            updateManualCategoryDropdown();
            initManualTimeSelects();
            renderGoalsProgress();
            
            // Initialize date input with today's date
            const today = toLocalDateInputValue(new Date());
            const statsDate = document.getElementById('statsDate');
            if (statsDate && !statsDate.value) {
                statsDate.value = today;
            }
        }

        function initManualTimeSelects() {
            const sh = document.getElementById('manualStartHour');
            const sm = document.getElementById('manualStartMinute');
            const eh = document.getElementById('manualEndHour');
            const em = document.getElementById('manualEndMinute');
            if (!sh || !sm || !eh || !em) return;

            sh.innerHTML = '';
            eh.innerHTML = '';
            for (let h = 0; h < 24; h++) {
                const opt = `<option value="${h}">${pad2(h)}</option>`;
                sh.insertAdjacentHTML('beforeend', opt);
                eh.insertAdjacentHTML('beforeend', opt);
            }

            sm.innerHTML = '';
            em.innerHTML = '';
            for (let m = 0; m < 60; m += 5) {
                const opt = `<option value="${m}">${pad2(m)}</option>`;
                sm.insertAdjacentHTML('beforeend', opt);
                em.insertAdjacentHTML('beforeend', opt);
            }

            const now = new Date();
            const round5 = Math.floor(now.getMinutes() / 5) * 5;
            sh.value = String(now.getHours());
            sm.value = String(round5);
            // default end = +30min
            const end = new Date(now.getTime() + 30 * 60000);
            const endRound5 = Math.floor(end.getMinutes() / 5) * 5;
            eh.value = String(end.getHours());
            em.value = String(endRound5);
        }

        // Load custom categories from localStorage
        function loadCustomCategories() {
            const saved = localStorage.getItem('customCategories');
            if (saved) {
                customCategories = JSON.parse(saved);
            }
        }

        // Save custom categories to localStorage
        function saveCustomCategories() {
            localStorage.setItem('customCategories', JSON.stringify(customCategories));
        }

        // Load logs from localStorage
        function loadLogs() {
            const saved = localStorage.getItem('timeLogs');
            if (saved) {
                timeLogs = JSON.parse(saved);
            }
        }

        // Save logs to localStorage
        function saveLogs() {
            localStorage.setItem('timeLogs', JSON.stringify(timeLogs));
        }

        // Render category cards
        function renderCategories() {
            const grid = document.getElementById('categoriesGrid');
            const allCategories = getAllCategories();
            const categoriesHtml = allCategories.map(category => {
                const isSelected = selectedCategory === category.id;
                const subs = getAllSubcategories(category.id);
                
                // Build subcategory options
                let subOptions = '<option value="">-- No subcategory --</option>';
                subs.forEach(sub => {
                    const selected = selectedSubcategory === sub ? 'selected' : '';
                    subOptions += `<option value="${sub}" ${selected}>${sub}</option>`;
                });
                subOptions += '<option value="__add_new__">➕ Add new...</option>';
                
                return `
                    <div class="category-card-wrapper">
                        <button
                            class="category-card ${isSelected ? 'active' : ''}"
                            onclick="selectCategory('${category.id}')"
                            style="background: ${isSelected ? category.color + '15' : 'white'}; ${isSelected ? 'box-shadow: 0 6px 20px ' + category.color + '35;' : ''}"
                        >
                            <span class="category-icon" style="background: ${category.color}20;">${category.icon}</span>
                            <span class="category-name" style="color: ${isSelected ? category.color : '#374151'}">${category.name}</span>
                        </button>
                        ${isSelected && subs.length > 0 ? `
                            <div class="subcategory-panel">
                                <select onchange="selectSubcategory(this.value)" ${activeTimer ? 'disabled' : ''}>
                                    ${subOptions}
                                </select>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            
            grid.innerHTML = categoriesHtml;
            updateManualCategoryDropdown();
        }
        
        // Update manual entry category dropdown when category is selected
        function selectCategory(categoryId) {
            if (activeTimer) return; // Can't change category while timer is running
            selectedCategory = categoryId;
            selectedSubcategory = null; // Reset subcategory when changing category
            renderCategories();
            updateManualCategoryDropdown();
        }

        // Select subcategory
        function selectSubcategory(value) {
            if (activeTimer) return;
            
            if (value === '__add_new__') {
                const newSub = prompt('Enter new subcategory name:');
                if (newSub && newSub.trim()) {
                    if (addCustomSubcategory(selectedCategory, newSub.trim())) {
                        selectedSubcategory = newSub.trim();
                        renderCategories();
                    } else {
                        alert('Subcategory already exists or is invalid.');
                        selectedSubcategory = null;
                        renderCategories();
                    }
                } else {
                    selectedSubcategory = null;
                    renderCategories();
                }
            } else {
                selectedSubcategory = value || null;
            }
        }

        // Format time
        function formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${String(hrs).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        // Format time in hours with one decimal place (0.0 format) for charts
        function formatTimeHours(seconds) {
            const hours = seconds / 3600;
            return hours.toFixed(1);
        }

        // Prefer calculating duration from recorded time period (endTime - startTime).
        // Fallback to stored duration for older records.
        function getDurationSeconds(log) {
            const start = Number(log.startTime);
            const end = Number(log.endTime);
            if (Number.isFinite(start) && Number.isFinite(end) && end >= start) {
                return Math.max(0, Math.floor((end - start) / 1000));
            }
            return Number(log.duration) || 0;
        }

        // Start timer
        function startTimer() {
            if (activeTimer) return;
            activeTimer = Date.now();
            elapsedTime = 0;
            updateTimeDisplay();
            
            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('stopBtn').classList.remove('hidden');
            document.getElementById('resetBtn').classList.remove('hidden');
            document.getElementById('activeTimerInfo').classList.remove('hidden');
            
            const category = getAllCategories().find(c => c.id === selectedCategory);
            document.getElementById('activeCategoryName').textContent = category.name;

            timerInterval = setInterval(() => {
                // Calculate from real time to avoid drift / tab sleep issues
                elapsedTime = Math.max(0, Math.floor((Date.now() - activeTimer) / 1000));
                updateTimeDisplay();
            }, 1000);
        }

        // Stop timer
        function stopTimer() {
            if (!activeTimer) return;
            
            clearInterval(timerInterval);
            // Calculate from real time to ensure accuracy
            const duration = Math.max(0, Math.floor((Date.now() - activeTimer) / 1000));
            const category = getAllCategories().find(c => c.id === selectedCategory);
            
            const newLog = {
                id: Date.now(),
                category: selectedCategory,
                categoryName: category.name,
                categoryColor: category.color,
                categoryIcon: category.icon,
                subcategory: selectedSubcategory || null,
                duration: duration,
                startTime: activeTimer,
                endTime: Date.now(),
                date: new Date().toISOString(),
                isManualEntry: false,
            };
            
            timeLogs.unshift(newLog);
            saveLogs();
            
            resetTimer();
            updateLogsView();
            renderGoalsProgress();
        }

        // Reset timer
        function resetTimer() {
            clearInterval(timerInterval);
            activeTimer = null;
            elapsedTime = 0;
            selectedSubcategory = null;
            
            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('stopBtn').classList.add('hidden');
            document.getElementById('resetBtn').classList.add('hidden');
            document.getElementById('activeTimerInfo').classList.add('hidden');
            
            updateTimeDisplay();
            renderCategories();
        }

        // Update time display
        function updateTimeDisplay() {
            document.getElementById('timeDisplay').textContent = formatTime(elapsedTime);
        }

        // Goals Functions
        function loadGoals() {
            const saved = localStorage.getItem('timeGoals');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Handle migration from old format
                    if (parsed && !Array.isArray(parsed)) {
                        goals = [];
                    } else {
                        goals = parsed || [];
                    }
                } catch (e) {
                    console.error('Error loading goals:', e);
                    goals = [];
                }
            } else {
                goals = [];
            }
        }

        function saveGoalsToStorage() {
            localStorage.setItem('timeGoals', JSON.stringify(goals));
        }

        let editingGoalId = null;

        function populateGoalCategoryDropdown() {
            const select = document.getElementById('goalCategory');
            if (!select) return;
            
            const allCategories = getAllCategories();
            select.innerHTML = '<option value="">-- Select Category --</option>';
            
            allCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = `${cat.icon} ${cat.name}`;
                select.appendChild(option);
            });
        }

        function updateGoalModalLabels() {
            const goalNameLabel = document.querySelector('label[for="goalName"]');
            if (goalNameLabel) goalNameLabel.textContent = t('goalName');
            
            const goalNameInput = document.getElementById('goalName');
            if (goalNameInput) goalNameInput.placeholder = t('goalNamePlaceholder');
            
            const goalPeriodLabel = document.querySelector('label[for="goalPeriod"]');
            if (goalPeriodLabel) goalPeriodLabel.textContent = t('timePeriod');
            
            const goalTargetLabel = document.querySelector('label[for="goalTarget"]');
            if (goalTargetLabel) goalTargetLabel.textContent = t('targetTime');
            
            const goalRepeatLabel = document.querySelector('label[for="goalRepeat"]');
            if (goalRepeatLabel) {
                const span = goalRepeatLabel.querySelector('span');
                if (span) span.textContent = t('repeatGoal');
                const desc = goalRepeatLabel.parentElement.querySelector('div[style*="font-size: 0.85rem"]');
                if (desc) desc.textContent = t('repeatGoalDesc');
            }
            
            const goalCategoryLabel = document.querySelector('label[for="goalCategory"]');
            if (goalCategoryLabel) {
                goalCategoryLabel.textContent = t('category') + ' *';
                const desc = goalCategoryLabel.parentElement.querySelector('div[style*="font-size: 0.85rem"]');
                if (desc) desc.textContent = t('onlyTimeLogged');
            }
            
            const goalSubcategoryLabel = document.querySelector('label[for="goalSubcategory"]');
            if (goalSubcategoryLabel) {
                goalSubcategoryLabel.textContent = t('subcategory');
                const desc = goalSubcategoryLabel.parentElement.querySelector('div[style*="font-size: 0.85rem"]');
                if (desc) desc.textContent = t('ifSelectedOnly');
            }
            
            const saveBtn = document.querySelector('#goalModal .btn-save');
            if (saveBtn) saveBtn.textContent = `💾 ${t('save')}`;
            
            const cancelBtn = document.querySelector('#goalModal .btn-cancel');
            if (cancelBtn) cancelBtn.textContent = `❌ ${t('cancel')}`;
            
            const deleteBtn = document.getElementById('goalDeleteBtn');
            if (deleteBtn) deleteBtn.textContent = `🗑️ ${t('delete')}`;
        }

        function updateGoalSubcategoryDropdown() {
            const catSelect = document.getElementById('goalCategory');
            const subSelect = document.getElementById('goalSubcategory');
            if (!catSelect || !subSelect) return;
            
            const categoryId = catSelect.value;
            subSelect.innerHTML = `<option value="">${t('allSubcategories')}</option>`;
            
            if (!categoryId) return;
            
            const category = getAllCategories().find(c => c.id === categoryId);
            if (!category) return;
            
            // Get default subcategories
            const defaultSubs = category.subcategories || [];
            defaultSubs.forEach(sub => {
                const option = document.createElement('option');
                option.value = sub;
                option.textContent = sub;
                subSelect.appendChild(option);
            });
            
            // Get custom subcategories
            const customSubs = customSubcategories[categoryId] || [];
            customSubs.forEach(sub => {
                if (!defaultSubs.includes(sub)) {
                    const option = document.createElement('option');
                    option.value = sub;
                    option.textContent = sub;
                    subSelect.appendChild(option);
                }
            });
        }

        function openAddGoalModal() {
            editingGoalId = null;
            document.getElementById('goalModalTitle').textContent = t('addNewGoal');
            document.getElementById('goalName').value = '';
            document.getElementById('goalCategory').value = '';
            document.getElementById('goalSubcategory').value = '';
            document.getElementById('goalPeriod').value = 'day';
            document.getElementById('goalTarget').value = '';
            document.getElementById('goalRepeat').checked = false;
            document.getElementById('goalDeleteBtn').classList.add('hidden');
            populateGoalCategoryDropdown();
            updateGoalSubcategoryDropdown();
            updateGoalModalLabels();
            document.getElementById('goalModal').classList.remove('hidden');
        }

        function openEditGoalModal(goalId) {
            const goal = goals.find(g => g.id === goalId);
            if (!goal) return;

            editingGoalId = goalId;
            document.getElementById('goalModalTitle').textContent = t('editGoal');
            document.getElementById('goalName').value = goal.name;
            populateGoalCategoryDropdown();
            document.getElementById('goalCategory').value = goal.category || '';
            updateGoalSubcategoryDropdown();
            document.getElementById('goalSubcategory').value = goal.subcategory || '';
            document.getElementById('goalPeriod').value = goal.period;
            document.getElementById('goalTarget').value = goal.target;
            document.getElementById('goalRepeat').checked = goal.repeat || false;
            document.getElementById('goalDeleteBtn').classList.remove('hidden');
            updateGoalModalLabels();
            document.getElementById('goalModal').classList.remove('hidden');
        }

        function closeGoalModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('goalModal').classList.add('hidden');
            editingGoalId = null;
        }

        function saveGoal() {
            const name = document.getElementById('goalName').value.trim();
            const category = document.getElementById('goalCategory').value;
            const subcategory = document.getElementById('goalSubcategory').value || null;
            const period = document.getElementById('goalPeriod').value;
            const target = parseFloat(document.getElementById('goalTarget').value);
            const repeat = document.getElementById('goalRepeat').checked;

            if (!name) {
                alert(t('pleaseEnterGoalName'));
                return;
            }

            if (!category) {
                alert(t('pleaseSelectCategory'));
                return;
            }

            if (!target || target <= 0) {
                alert(t('pleaseEnterValidTarget'));
                return;
            }

            if (editingGoalId) {
                // Update existing goal
                const goalIndex = goals.findIndex(g => g.id === editingGoalId);
                if (goalIndex !== -1) {
                    goals[goalIndex] = {
                        id: editingGoalId,
                        name,
                        category,
                        subcategory,
                        period,
                        target,
                        repeat: repeat || false
                    };
                }
            } else {
                // Add new goal
                goals.push({
                    id: Date.now(),
                    name,
                    category,
                    subcategory,
                    period,
                    target,
                    repeat: repeat || false
                });
            }

            saveGoalsToStorage();
            closeGoalModal();
            renderGoalsProgress();
        }

        function deleteGoal() {
            if (!editingGoalId) return;
            
            if (confirm(t('deleteGoalConfirm'))) {
                goals = goals.filter(g => g.id !== editingGoalId);
                saveGoalsToStorage();
                closeGoalModal();
                renderGoalsProgress();
            }
        }

        function getCurrentTimeForPeriod(period, category = null, subcategory = null) {
            const now = new Date();
            let startMs, endMs;

            if (period === 'day') {
                startMs = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0).getTime();
                endMs = startMs + 24 * 3600 * 1000;
            } else if (period === 'week') {
                const day = now.getDay();
                const diffToMonday = (day === 0 ? -6 : 1 - day);
                const monday = new Date(now);
                monday.setDate(now.getDate() + diffToMonday);
                monday.setHours(0, 0, 0, 0);
                startMs = monday.getTime();
                endMs = startMs + 7 * 24 * 3600 * 1000;
            } else if (period === 'month') {
                startMs = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0).getTime();
                endMs = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0, 0).getTime();
            } else if (period === 'year') {
                startMs = new Date(now.getFullYear(), 0, 1, 0, 0, 0, 0).getTime();
                endMs = new Date(now.getFullYear() + 1, 0, 1, 0, 0, 0, 0).getTime();
            } else {
                return 0;
            }

            // Filter logs within the period and matching category/subcategory
            const logsInPeriod = timeLogs.filter(log => {
                const endMsLog = getLogEndTimeMs(log);
                const inPeriod = Number.isFinite(endMsLog) && endMsLog >= startMs && endMsLog < endMs;
                
                if (!inPeriod) return false;
                
                // Filter by category if specified
                if (category && log.category !== category) return false;
                
                // Filter by subcategory if specified
                if (subcategory !== null && log.subcategory !== subcategory) return false;
                
                return true;
            });

            // Sum up all durations
            return logsInPeriod.reduce((sum, log) => sum + getDurationSeconds(log), 0);
        }

        function renderGoalsProgress() {
            const display = document.getElementById('goalsDisplay');
            if (!display) return;

            if (!goals || goals.length === 0) {
                display.innerHTML = `<div style="text-align: center; color: #6b7280; padding: 20px;">${t('noGoalsSet')}</div>`;
                return;
            }

            const periodLabels = {
                day: t('today'),
                week: t('thisWeek'),
                month: t('thisMonth'),
                year: t('thisYear')
            };

            const periodIcons = {
                day: '📅',
                week: '📆',
                month: '🗓️',
                year: '📊'
            };

            let html = '';
            goals.forEach(goal => {
                // Skip goals without category (old format or deleted category)
                if (!goal.category) {
                    return;
                }
                
                // Get category info
                const category = getAllCategories().find(c => c.id === goal.category);
                if (!category) {
                    // Category was deleted, skip this goal
                    return;
                }
                const categoryName = category.name;
                const categoryIcon = category.icon;
                
                // Calculate progress with category/subcategory filtering
                const currentSeconds = getCurrentTimeForPeriod(goal.period, goal.category, goal.subcategory);
                const currentHours = currentSeconds / 3600;
                const goalHours = goal.target;
                const percentage = goalHours > 0 ? Math.min(100, (currentHours / goalHours) * 100) : 0;
                const remaining = Math.max(0, goalHours - currentHours);

                let statusClass = '';
                let statusText = '';
                if (percentage >= 100) {
                    statusClass = 'over-goal';
                    statusText = `✓ ${t('goalAchieved')}`;
                } else if (percentage >= 75) {
                    statusClass = 'warning';
                    statusText = t('almostThere');
                } else {
                    statusText = `${remaining.toFixed(1)}h ${t('remaining')}`;
                }

                const repeatBadge = goal.repeat ? `<span class="goal-repeat-badge" title="${t('repeatGoal')}">🔄 ${t('repeatGoal').split(' ')[0]}</span>` : '';
                const categoryInfo = goal.subcategory 
                    ? `${categoryIcon} ${categoryName} → ${goal.subcategory}`
                    : `${categoryIcon} ${categoryName}`;
                
                html += `
                    <div class="goal-item ${goal.repeat ? 'goal-item-repeat' : ''}">
                        <div class="goal-item-header">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span class="goal-item-title">${goal.name}</span>
                                ${repeatBadge}
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span class="goal-item-progress">${currentHours.toFixed(1)}h / ${goalHours.toFixed(1)}h</span>
                                <div class="goal-item-actions">
                                    <button class="goal-item-edit-btn" onclick="openEditGoalModal(${goal.id})" title="${t('editGoal')}">✏️</button>
                                    <button class="goal-item-delete-btn" onclick="deleteGoalById(${goal.id})" title="${t('delete')}">🗑️</button>
                                </div>
                            </div>
                        </div>
                        <div style="font-size: 0.85rem; color: #6b7280; margin-bottom: 8px;">
                            ${periodIcons[goal.period]} ${periodLabels[goal.period]}${goal.repeat ? ` ${t('repeatsEachPeriod')}` : ''} • ${categoryInfo}
                        </div>
                        <div class="goal-progress-bar-container">
                            <div class="goal-progress-bar ${statusClass}" style="width: ${percentage}%">
                                ${percentage >= 10 ? `${percentage.toFixed(0)}%` : ''}
                            </div>
                            <div class="goal-progress-text">${statusText}</div>
                        </div>
                    </div>
                `;
            });

            display.innerHTML = html;
        }

        function deleteGoalById(goalId) {
            if (confirm(t('deleteGoalConfirm'))) {
                goals = goals.filter(g => g.id !== goalId);
                saveGoalsToStorage();
                renderGoalsProgress();
            }
        }

        // Switch view
        function switchView(view) {
            const trackerView = document.getElementById('trackerView');
            const logsView = document.getElementById('logsView');
            const trackerBtn = document.getElementById('trackerBtn');
            const logsBtn = document.getElementById('logsBtn');

            trackerView.classList.add('hidden');
            logsView.classList.add('hidden');
            trackerBtn.classList.remove('active');
            logsBtn.classList.remove('active');

            if (view === 'tracker') {
                trackerView.classList.remove('hidden');
                trackerBtn.classList.add('active');
                renderGoalsProgress();
            } else {
                logsView.classList.remove('hidden');
                logsBtn.classList.add('active');
                updateLogsView();
                renderOverview();
            }
        }

        function pad2(n) {
            return String(n).padStart(2, '0');
        }

        function toLocalDateInputValue(d) {
            return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
        }

        function getDayBoundsFromInput(dateStr) {
            // dateStr in YYYY-MM-DD, interpret as local day
            const [y, m, d] = dateStr.split('-').map(Number);
            const start = new Date(y, m - 1, d, 0, 0, 0, 0);
            const end = new Date(y, m - 1, d + 1, 0, 0, 0, 0);
            return { start, end };
        }

        function formatHM(ts) {
            const d = new Date(ts);
            return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function clamp(n, min, max) {
            return Math.max(min, Math.min(max, n));
        }

        function splitLogToDaySegments(log, dayStartMs, dayEndMs) {
            const start = Number(log.startTime);
            const end = Number(log.endTime);
            if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) return [];

            const segStart = clamp(start, dayStartMs, dayEndMs);
            const segEnd = clamp(end, dayStartMs, dayEndMs);
            if (segEnd <= segStart) return [];

            return [{
                log,
                startMs: segStart,
                endMs: segEnd
            }];
        }

        // Helper function to round to nice increments for chart scales
        function roundToNiceIncrement(value) {
            if (value <= 0) return 1;
            // Convert seconds to hours for easier rounding
            const hours = value / 3600;
            let rounded;
            
            if (hours < 0.5) {
                // Round to nearest 0.1h for very small values
                rounded = Math.ceil(hours * 10) / 10;
            } else if (hours < 2) {
                // Round to nearest 0.5h
                rounded = Math.ceil(hours * 2) / 2;
            } else if (hours < 10) {
                // Round to nearest 1h
                rounded = Math.ceil(hours);
            } else if (hours < 50) {
                // Round to nearest 5h
                rounded = Math.ceil(hours / 5) * 5;
            } else {
                // Round to nearest 10h
                rounded = Math.ceil(hours / 10) * 10;
            }
            
            // Convert back to seconds
            return rounded * 3600;
        }

        // Generate histogram chart HTML
        function generateHistogramChart(data, labels, title, includeContainer = true) {
            if (!data || data.length === 0) return '';
            
            const rawMaxValue = Math.max(...data.map(d => d.value), 1);
            const maxValue = roundToNiceIncrement(rawMaxValue);
            const maxHeight = 200;
            const gradients = [
                'linear-gradient(180deg, #667eea 0%, #764ba2 100%)',
                'linear-gradient(180deg, #10b981 0%, #059669 100%)',
                'linear-gradient(180deg, #f59e0b 0%, #d97706 100%)',
                'linear-gradient(180deg, #ef4444 0%, #dc2626 100%)',
                'linear-gradient(180deg, #8b5cf6 0%, #7c3aed 100%)',
                'linear-gradient(180deg, #ec4899 0%, #db2777 100%)',
                'linear-gradient(180deg, #14b8a6 0%, #0d9488 100%)',
                'linear-gradient(180deg, #06b6d4 0%, #0891b2 100%)'
            ];
            
            let html = '';
            if (includeContainer) {
                html += `<div class="chart-container">`;
                if (title) {
                    html += `<div class="chart-title">${title}</div>`;
                }
            }
            html += `<div class="histogram-chart">`;
            
            data.forEach((item, idx) => {
                const height = Math.max((item.value / maxValue) * maxHeight, 8); // Minimum 8px for visibility
                const gradient = item.color || gradients[idx % gradients.length];
                html += `
                    <div class="histogram-bar">
                        <div class="histogram-bar-column" style="height: ${height}px; background: ${gradient};">
                            <div class="histogram-bar-value">${formatTimeHours(item.value)}h</div>
                        </div>
                        <div class="histogram-bar-label">${labels[idx] || item.label || ''}</div>
                    </div>
                `;
            });
            
            html += `</div>`;
            if (includeContainer) {
                html += `</div>`;
            }
            return html;
        }

        // Generate line chart HTML (SVG)
        function generateLineChart(dataSeries, labels, title, includeContainer = true) {
            if (!dataSeries || dataSeries.length === 0) return '';
            
            // Use responsive width that fits container
            const baseWidth = 600; // Base width for viewBox calculations
            const chartWidth = baseWidth; // Use for viewBox
            const plotAreaHeight = 240; // Reduced height for the actual plot area
            const labelAreaHeight = 60; // Space for labels
            const chartHeight = plotAreaHeight + labelAreaHeight; // Total SVG height = 300
            const padding = { top: 30, right: 40, bottom: 20, left: 70 }; // Padding for labels
            const plotWidth = baseWidth - padding.left - padding.right;
            const plotHeight = plotAreaHeight - padding.top - padding.bottom;
            
            // Find max value across all series
            let rawMaxValue = 0;
            dataSeries.forEach(series => {
                series.data.forEach(val => {
                    if (val > rawMaxValue) rawMaxValue = val;
                });
            });
            const maxValue = roundToNiceIncrement(Math.max(rawMaxValue, 1));
            
            // Generate path for each series
            const defaultColors = ['#667eea', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#14b8a6', '#06b6d4'];
            
            let html = '';
            if (includeContainer) {
                html += `<div class="chart-container">`;
                if (title) {
                    html += `<div class="chart-title">${title}</div>`;
                }
            }
            html += `<div class="line-chart-container">`;
            html += `<svg class="line-chart-svg" viewBox="0 0 ${baseWidth} ${chartHeight}" preserveAspectRatio="xMidYMin meet" style="width: 100%; height: ${chartHeight}px; display: block;">`;
            
            // Draw grid lines (use 6 divisions for better granularity)
            const gridDivisions = 6;
            for (let i = 0; i <= gridDivisions; i++) {
                const y = padding.top + (plotHeight / gridDivisions) * i;
                const value = maxValue - (maxValue / gridDivisions) * i;
                html += `<line class="line-chart-grid" x1="${padding.left}" y1="${y}" x2="${padding.left + plotWidth}" y2="${y}"/>`;
                html += `<text class="line-chart-label" x="${padding.left - 12}" y="${y + 5}" text-anchor="end" font-family="'Courier New', monospace">${formatTimeHours(Math.floor(value))}h</text>`;
            }
            
            // Draw axis
            html += `<line class="line-chart-axis" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + plotHeight}"/>`;
            const axisY = padding.top + plotHeight;
            html += `<line class="line-chart-axis" x1="${padding.left}" y1="${axisY}" x2="${padding.left + plotWidth}" y2="${axisY}"/>`;
            
            // Draw lines and points for each series
            dataSeries.forEach((series, seriesIdx) => {
                const color = series.color || defaultColors[seriesIdx % defaultColors.length];
                const points = series.data.map((value, idx) => {
                    const x = padding.left + (plotWidth / (series.data.length - 1 || 1)) * idx;
                    const y = padding.top + plotHeight - (value / maxValue) * plotHeight;
                    return `${x},${y}`;
                }).join(' ');
                
                // Draw line
                html += `<polyline class="line-chart-line" points="${points}" stroke="${color}" fill="none"/>`;
                
                // Draw points
                series.data.forEach((value, idx) => {
                    const x = padding.left + (plotWidth / (series.data.length - 1 || 1)) * idx;
                    const y = padding.top + plotHeight - (value / maxValue) * plotHeight;
                    html += `<circle class="line-chart-point" cx="${x}" cy="${y}" r="5" stroke="${color}" fill="white" stroke-width="3" data-value="${formatTimeHours(value)}h" data-label="${labels[idx] || ''}"/>`;
                });
            });
            
            // Draw labels on x-axis (horizontal to save space and ensure visibility)
            if (labels && labels.length > 0) {
                labels.forEach((label, idx) => {
                    if (label) { // Only render if label exists
                        const x = padding.left + (plotWidth / (labels.length - 1 || 1)) * idx;
                        // Position labels horizontally at the bottom of the chart
                        const labelY = plotAreaHeight + 40; // Position in label area (240 + 40 = 280, well within 300)
                        // Render label horizontally (no rotation) for better visibility and compactness
                        html += `<text class="line-chart-label" x="${x}" y="${labelY}" text-anchor="middle" font-size="0.75rem" fill="#1e293b" font-weight="600" style="dominant-baseline: middle; pointer-events: none; opacity: 1;">${label}</text>`;
                    }
                });
            }
            
            html += `</svg>`;
            
            // Add legend
            html += `<div class="line-chart-legend">`;
            dataSeries.forEach((series, idx) => {
                const color = series.color || defaultColors[idx % defaultColors.length];
                html += `
                    <div class="line-chart-legend-item">
                        <div class="line-chart-legend-color" style="background: ${color};"></div>
                        <span>${series.name}</span>
                    </div>
                `;
            });
            html += `</div>`;
            
            if (includeContainer) {
                html += `</div></div>`;
            }
            return html;
        }

        // Generate column/bar chart HTML (SVG) for comparing different categories
        function generateColumnChart(categoryData, labels, title) {
            if (!categoryData || categoryData.length === 0) return '';
            
            const chartWidth = 800;
            const chartHeight = 320;
            const padding = { top: 30, right: 30, bottom: 60, left: 85 };
            const plotWidth = chartWidth - padding.left - padding.right;
            const plotHeight = chartHeight - padding.top - padding.bottom;
            
            // Get all categories and find max value
            const allCategories = categoryData.map(d => Object.keys(d.values)).flat();
            const uniqueCategories = [...new Set(allCategories)];
            const rawMaxValue = Math.max(...categoryData.map(d => 
                Math.max(...Object.values(d.values))
            ), 1);
            const maxValue = roundToNiceIncrement(rawMaxValue);
            
            // Get category colors
            const categoryColors = {};
            categoryData.forEach(d => {
                Object.keys(d.values).forEach(catId => {
                    if (!categoryColors[catId]) {
                        const cat = getAllCategories().find(c => c.id === catId);
                        categoryColors[catId] = cat ? cat.color : '#667eea';
                    }
                });
            });
            
            const numDays = labels.length;
            const numCategories = uniqueCategories.length;
            const groupWidth = plotWidth / numDays;
            const barWidth = groupWidth / (numCategories + 1);
            const barSpacing = barWidth * 0.2;
            const actualBarWidth = barWidth - barSpacing;
            
            let html = `<div class="column-chart-container">`;
            html += `<svg class="column-chart-svg" viewBox="0 0 ${chartWidth} ${chartHeight}" preserveAspectRatio="xMidYMid meet">`;
            
            // Draw grid lines (use 6 divisions for better granularity)
            const gridDivisions = 6;
            for (let i = 0; i <= gridDivisions; i++) {
                const y = padding.top + (plotHeight / gridDivisions) * i;
                const value = maxValue - (maxValue / gridDivisions) * i;
                html += `<line class="line-chart-grid" x1="${padding.left}" y1="${y}" x2="${padding.left + plotWidth}" y2="${y}"/>`;
                html += `<text class="line-chart-label" x="${padding.left - 12}" y="${y + 5}" text-anchor="end" font-family="'Courier New', monospace">${formatTimeHours(Math.floor(value))}h</text>`;
            }
            
            // Draw axis
            html += `<line class="line-chart-axis" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + plotHeight}"/>`;
            html += `<line class="line-chart-axis" x1="${padding.left}" y1="${padding.top + plotHeight}" x2="${padding.left + plotWidth}" y2="${padding.top + plotHeight}"/>`;
            
            // Draw columns for each day
            categoryData.forEach((dayData, dayIdx) => {
                const groupX = padding.left + (groupWidth * dayIdx) + (groupWidth / 2);
                let barX = groupX - (barWidth * numCategories / 2) + (barWidth / 2);
                
                uniqueCategories.forEach((catId, catIdx) => {
                    const value = dayData.values[catId] || 0;
                    if (value > 0) {
                        const barHeight = (value / maxValue) * plotHeight;
                        const barY = padding.top + plotHeight - barHeight;
                        const x = barX - (actualBarWidth / 2);
                        
                        html += `<rect class="column-bar" x="${x}" y="${barY}" width="${actualBarWidth}" height="${barHeight}" fill="${categoryColors[catId]}" rx="4"/>`;
                        
                        // Add value label on top if bar is tall enough
                        if (barHeight > 20) {
                            html += `<text class="column-value" x="${barX}" y="${barY - 5}" font-size="0.65rem">${formatTimeHours(value)}h</text>`;
                        }
                    }
                    barX += barWidth;
                });
                
                // Day label
                html += `<text class="column-label" x="${groupX}" y="${chartHeight - 15}" transform="rotate(-45 ${groupX} ${chartHeight - 15})">${labels[dayIdx]}</text>`;
            });
            
            html += `</svg>`;
            
            // Add legend
            html += `<div class="line-chart-legend">`;
            uniqueCategories.forEach(catId => {
                const cat = getAllCategories().find(c => c.id === catId);
                if (cat) {
                    html += `
                        <div class="line-chart-legend-item">
                            <div class="line-chart-legend-color" style="background: ${cat.color};"></div>
                            <span>${cat.icon} ${cat.name}</span>
                        </div>
                    `;
                }
            });
            html += `</div>`;
            
            html += `</div>`;
            return html;
        }

        // Store selected categories separately for each chart
        window.selectedCategoriesHistogram = window.selectedCategoriesHistogram || new Set();
        window.selectedCategoriesLine = window.selectedCategoriesLine || new Set();

        function toggleCategoryDropdown(chartType, event) {
            if (event) {
                event.stopPropagation();
            }
            
            // Close all other dropdowns
            document.querySelectorAll('.category-dropdown').forEach(dropdown => {
                if (dropdown.id !== `categoryDropdown_${chartType}`) {
                    dropdown.style.display = 'none';
                }
            });
            
            const dropdown = document.getElementById(`categoryDropdown_${chartType}`);
            if (dropdown) {
                const isVisible = dropdown.style.display === 'block';
                dropdown.style.display = isVisible ? 'none' : 'block';
            }
        }

        function toggleCategorySelection(chartType, categoryId) {
            const selectedSet = chartType === 'histogram' ? window.selectedCategoriesHistogram : window.selectedCategoriesLine;
            const btn = document.getElementById(`catOption_${chartType}_${categoryId}`);
            
            if (!btn || !selectedSet) return;

            if (selectedSet.has(categoryId)) {
                selectedSet.delete(categoryId);
                btn.classList.remove('selected');
            } else {
                selectedSet.add(categoryId);
                btn.classList.add('selected');
            }

            // Update the specific chart
            if (chartType === 'histogram') {
                updateHistogramChart();
            } else {
                updateLineChart();
            }
        }

        // Function to generate category dropdown HTML (global for use in week, month, year views)
        function generateCategoryDropdown(chartType, allSeries) {
            const selectedSet = chartType === 'histogram' ? window.selectedCategoriesHistogram : window.selectedCategoriesLine;
            let dropdownHtml = `
                <div class="category-selector-wrapper">
                    <button class="category-selector-icon" onclick="toggleCategoryDropdown('${chartType}', event)" title="Select Categories">
                        📊
                    </button>
                    <div class="category-dropdown" id="categoryDropdown_${chartType}">
            `;
            
            allSeries.forEach((series) => {
                const isSelected = selectedSet.has(series.id);
                dropdownHtml += `
                    <div class="category-option ${isSelected ? 'selected' : ''}" 
                         id="catOption_${chartType}_${series.id}"
                         onclick="toggleCategorySelection('${chartType}', '${series.id}')">
                        <span>${series.nameOnly || series.name}</span>
                    </div>
                `;
            });
            
            dropdownHtml += `
                    </div>
                </div>
            `;
            return dropdownHtml;
        }

        function updateHistogramChart() {
            // Determine which view is active
            const rangeSelect = document.getElementById('statsRange');
            const range = rangeSelect ? rangeSelect.value : 'week';
            
            let container, chartData;
            if (range === 'week') {
                container = document.getElementById('weekHistogramContainer');
                chartData = window.weekChartData;
            } else if (range === 'month') {
                container = document.getElementById('monthHistogramContainer');
                chartData = window.monthChartData;
            } else if (range === 'year') {
                container = document.getElementById('yearHistogramContainer');
                chartData = window.yearChartData;
            } else {
                return;
            }
            
            if (!container || !chartData) return;

            const selectedIds = Array.from(window.selectedCategoriesHistogram);
            
            if (selectedIds.length === 0) {
                container.innerHTML = '<div class="empty-state">Please select at least one category.</div>';
                return;
            }

            if (chartData.categoryTotals) {
                const totalTimeData = selectedIds
                    .map(catId => {
                        const catData = chartData.categoryTotals[catId];
                        if (!catData) return null;
                        return {
                            value: catData.time,
                            label: catData.name, // Only name, no icon
                            color: catData.color
                        };
                    })
                    .filter(item => item !== null);

                if (totalTimeData.length > 0) {
                    container.innerHTML = generateHistogramChart(totalTimeData, totalTimeData.map(d => d.label), '', false);
                }
            }
        }

        function updateLineChart() {
            // Determine which view is active
            const rangeSelect = document.getElementById('statsRange');
            const range = rangeSelect ? rangeSelect.value : 'week';
            
            let container, chartData;
            if (range === 'week') {
                container = document.getElementById('weekLineChartContainer');
                chartData = window.weekChartData;
            } else if (range === 'month') {
                container = document.getElementById('monthLineChartContainer');
                chartData = window.monthChartData;
            } else if (range === 'year') {
                container = document.getElementById('yearLineChartContainer');
                chartData = window.yearChartData;
            } else {
                return;
            }
            
            if (!container || !chartData) return;

            const selectedIds = Array.from(window.selectedCategoriesLine);
            
            if (selectedIds.length === 0) {
                container.innerHTML = '<div class="empty-state">Please select at least one category.</div>';
                return;
            }

            const selectedSeries = chartData.allSeries
                .filter(series => selectedIds.includes(series.id))
                .map(s => ({
                    name: s.nameOnly || s.name.replace(/^[^\w\s]+/, '').trim(), // Only name, no icon
                    data: s.data,
                    color: s.color
                }));

            if (selectedSeries.length > 0) {
                container.innerHTML = generateLineChart(selectedSeries, chartData.labels, '', false);
            }
        }

        // Close dropdowns when clicking outside
        if (typeof document !== 'undefined') {
            document.addEventListener('click', function(event) {
                if (!event.target.closest('.category-selector-wrapper')) {
                    document.querySelectorAll('.category-dropdown').forEach(dropdown => {
                        dropdown.style.display = 'none';
                    });
                }
            });
        }

        function renderOverview() {
            const dateInput = document.getElementById('statsDate');
            const grid = document.getElementById('timelineGrid');
            const summary = document.getElementById('overviewSummary');
            const rangeSelect = document.getElementById('statsRange');
            if (!dateInput || !grid) return;

            // default date to today
            if (!dateInput.value) {
                dateInput.value = toLocalDateInputValue(new Date());
            }

            const baseStr = dateInput.value;
            const [y, m, d] = baseStr.split('-').map(Number);
            const baseDate = new Date(y, m - 1, d);
            const range = rangeSelect ? rangeSelect.value : 'day';

            // Clear summary initially
            if (summary) summary.innerHTML = '';

            // Day view: show as a clear table/chart
            if (range === 'day') {
                const { start, end } = getDayBoundsFromInput(baseStr);
                const dayStartMs = start.getTime();
                const dayEndMs = end.getTime();

                // Collect segments within this day
                let segments = [];
                timeLogs.forEach(log => {
                    const parts = splitLogToDaySegments(log, dayStartMs, dayEndMs);
                    segments = segments.concat(parts);
                });

                // Sort by start time
                segments.sort((a, b) => a.startMs - b.startMs);

                if (segments.length === 0) {
                    grid.innerHTML = `<div class="timeline-empty">No records for this day.</div>`;
                    return;
                }

                // Calculate total time
                let totalSeconds = 0;
                segments.forEach(({ startMs, endMs }) => {
                    totalSeconds += Math.floor((endMs - startMs) / 1000);
                });

                // Build table
                let tableHtml = `
                    <div class="overview-table-container">
                        <table class="overview-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Time Period</th>
                                    <th>Category</th>
                                    <th>Subcategory</th>
                                    <th>Duration</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                segments.forEach(({ log, startMs, endMs }, index) => {
                    const catName = log.categoryName || 'Unknown';
                    const catIcon = log.categoryIcon || '📌';
                    const catColor = log.categoryColor || '#6b7280';
                    const period = `${formatHM(startMs)} - ${formatHM(endMs)}`;
                    const durationSec = Math.floor((endMs - startMs) / 1000);
                    const dur = formatTime(durationSec);

                    tableHtml += `
                        <tr>
                            <td class="col-num">${index + 1}</td>
                            <td class="col-time">${period}</td>
                            <td class="col-category">
                                <span class="cat-badge" style="background: ${catColor}22; border-color: ${catColor};">
                                    ${catIcon} ${catName}
                                </span>
                            </td>
                            <td class="col-sub">${log.subcategory || '-'}</td>
                            <td class="col-duration">${dur}</td>
                        </tr>
                    `;
                });

                tableHtml += `
                            </tbody>
                            <tfoot>
                                <tr>
                                    <td colspan="4" class="total-label">Total (${segments.length} records)</td>
                                    <td class="total-value">${formatTime(totalSeconds)}</td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                `;

                grid.innerHTML = tableHtml;
                if (summary) summary.innerHTML = '';
                return;
            }

            // For week / month / year: show charts and comparisons
            // Compute range bounds based on base date
            let rangeStart, rangeEnd;
            if (range === 'week') {
                const day = baseDate.getDay(); // 0 Sun - 6 Sat
                const diffToMonday = (day === 0 ? -6 : 1 - day);
                rangeStart = new Date(baseDate);
                rangeStart.setDate(baseDate.getDate() + diffToMonday);
                rangeStart.setHours(0, 0, 0, 0);
                rangeEnd = new Date(rangeStart);
                rangeEnd.setDate(rangeStart.getDate() + 7);
            } else if (range === 'month') {
                rangeStart = new Date(baseDate.getFullYear(), baseDate.getMonth(), 1, 0, 0, 0, 0);
                rangeEnd = new Date(baseDate.getFullYear(), baseDate.getMonth() + 1, 1, 0, 0, 0, 0);
            } else if (range === 'year') {
                rangeStart = new Date(baseDate.getFullYear(), 0, 1, 0, 0, 0, 0);
                rangeEnd = new Date(baseDate.getFullYear() + 1, 0, 1, 0, 0, 0, 0);
            } else {
                // Fallback to week if unknown
                rangeStart = new Date(baseDate);
                rangeStart.setHours(0, 0, 0, 0);
                rangeEnd = new Date(rangeStart);
                rangeEnd.setDate(rangeStart.getDate() + 1);
            }

            const startMs = rangeStart.getTime();
            const endMs = rangeEnd.getTime();

            // Filter logs by range using end time
            const logsInRange = timeLogs.filter(log => {
                const endMsLog = getLogEndTimeMs(log);
                return Number.isFinite(endMsLog) && endMsLog >= startMs && endMsLog < endMs;
            });

            if (logsInRange.length === 0) {
                grid.innerHTML = '<div class="timeline-empty">No records for this range.</div>';
                if (summary) summary.innerHTML = '';
                return;
            }

            // Calculate category totals
            const categoryTotals = {};
            logsInRange.forEach(log => {
                if (!categoryTotals[log.category]) {
                    categoryTotals[log.category] = {
                        time: 0,
                        name: log.categoryName,
                        color: log.categoryColor,
                        icon: log.categoryIcon,
                    };
                }
                categoryTotals[log.category].time += getDurationSeconds(log);
            });

            // Sort by time (descending)
            const sortedCategories = Object.entries(categoryTotals)
                .sort((a, b) => b[1].time - a[1].time);

            const maxTime = Math.max(...sortedCategories.map(([_, data]) => data.time), 1);
            const totalTime = sortedCategories.reduce((sum, [_, data]) => sum + data.time, 0);

            // Build chart HTML (no category comparison for any view)
            let chartHtml = '';

            // Add histogram and line charts for week/month/year views
            if (range === 'week') {
                // Prepare data for week view
                const byDate = {};
                logsInRange.forEach(log => {
                    const end = getLogEndTimeMs(log);
                    const dKey = new Date(end).toDateString();
                    if (!byDate[dKey]) byDate[dKey] = [];
                    byDate[dKey].push(log);
                });

                const dateKeys = Object.keys(byDate).sort((a, b) => new Date(a) - new Date(b));
                
                // Prepare data for column chart (different categories by day)
                const columnChartData = dateKeys.map(key => {
                    const dayLogs = byDate[key];
                    const values = {};
                    sortedCategories.forEach(([catId]) => {
                        const catLogs = dayLogs.filter(log => log.category === catId);
                        values[catId] = catLogs.reduce((sum, log) => sum + getDurationSeconds(log), 0);
                    });
                    return { values };
                });

                // Prepare data for line chart (same category trends)
                const categoryByDay = {};
                sortedCategories.forEach(([catId, catData]) => {
                    categoryByDay[catId] = dateKeys.map(key => {
                        const logs = byDate[key].filter(log => log.category === catId);
                        return logs.reduce((sum, log) => sum + getDurationSeconds(log), 0);
                    });
                });

                const dayLabels = dateKeys.map(key => {
                    const d = new Date(key);
                    return d.toLocaleDateString('en-US', { weekday: 'short', day: 'numeric' });
                });

                // Prepare all category data
                const allCategorySeries = sortedCategories.map(([catId, catData]) => ({
                    id: catId,
                    name: `${catData.icon} ${catData.name}`,
                    nameOnly: catData.name, // Just the name without icon
                    data: categoryByDay[catId] || [],
                    color: catData.color,
                    icon: catData.icon,
                    time: catData.time
                })).filter(series => series.data.some(val => val > 0) || series.time > 0);

                // Store data for chart updates
                const categoryTotals = {};
                sortedCategories.forEach(([catId, catData]) => {
                    categoryTotals[catId] = {
                        time: catData.time,
                        icon: catData.icon,
                        name: catData.name,
                        color: catData.color
                    };
                });

                // Initialize selected categories separately for each chart (first 3 by default)
                window.selectedCategoriesHistogram = new Set();
                window.selectedCategoriesLine = new Set();
                allCategorySeries.slice(0, 3).forEach(series => {
                    window.selectedCategoriesHistogram.add(series.id);
                    window.selectedCategoriesLine.add(series.id);
                });

                // Generate initial charts with selected categories
                const initialHistogramIds = Array.from(window.selectedCategoriesHistogram);
                const initialLineIds = Array.from(window.selectedCategoriesLine);
                
                const initialTotalTimeData = initialHistogramIds
                    .map(catId => {
                        const catData = categoryTotals[catId];
                        if (!catData) return null;
                        return {
                            value: catData.time,
                            label: catData.name, // Only name, no icon
                            color: catData.color
                        };
                    })
                    .filter(item => item !== null);

                const initialSelectedSeries = allCategorySeries
                    .filter(s => initialLineIds.includes(s.id))
                    .map(s => ({
                        name: s.nameOnly || s.name.replace(/^[^\w\s]+/, '').trim(), // Only name, no icon
                        data: s.data,
                        color: s.color
                    }));

                // Generate charts without outer containers
                const histogramInnerHtml = generateHistogramChart(initialTotalTimeData, initialTotalTimeData.map(d => d.label), '', false);
                const lineChartInnerHtml = generateLineChart(initialSelectedSeries, dayLabels, '', false);

                // Store data globally for updates
                window.weekChartData = {
                    allSeries: allCategorySeries,
                    labels: dayLabels,
                    dayLabels: dayLabels,
                    categoryTotals: categoryTotals
                };

                // Wrap both charts in a flex container to display side by side
                chartHtml += `
                    <div class="charts-row-container">
                        <div class="chart-container">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                <div class="chart-title" style="margin-bottom: 0;">📊 Total Time by Category (Week)</div>
                                ${generateCategoryDropdown('histogram', allCategorySeries)}
                            </div>
                            <div id="weekHistogramContainer">
                                ${histogramInnerHtml}
                            </div>
                        </div>
                        <div class="chart-container">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                <div class="chart-title" style="margin-bottom: 0;">📈 Category Trends by Day</div>
                                ${generateCategoryDropdown('line', allCategorySeries)}
                            </div>
                            <div id="weekLineChartContainer">
                                ${lineChartInnerHtml}
                            </div>
                        </div>
                    </div>
                `;
            } else if (range === 'month') {
                // Prepare data by week
                const byWeek = {};
                logsInRange.forEach(log => {
                    const end = getLogEndTimeMs(log);
                    const date = new Date(end);
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay() + (date.getDay() === 0 ? -6 : 1));
                    weekStart.setHours(0, 0, 0, 0);
                    const weekKey = weekStart.toISOString().split('T')[0];
                    if (!byWeek[weekKey]) byWeek[weekKey] = [];
                    byWeek[weekKey].push(log);
                });

                const weekKeys = Object.keys(byWeek).sort();
                
                // Calculate category totals for the month
                const categoryTotals = {};
                logsInRange.forEach(log => {
                    if (!categoryTotals[log.category]) {
                        const catData = getAllCategories().find(c => c.id === log.category);
                        categoryTotals[log.category] = {
                            time: 0,
                            icon: catData?.icon || '📁',
                            name: catData?.name || log.category,
                            color: catData?.color || '#667eea'
                        };
                    }
                    categoryTotals[log.category].time += getDurationSeconds(log);
                });

                // Prepare category data by week
                const categoryByWeek = {};
                sortedCategories.forEach(([catId, catData]) => {
                    categoryByWeek[catId] = weekKeys.map(weekKey => {
                        const logs = byWeek[weekKey].filter(log => log.category === catId);
                        return logs.reduce((sum, log) => sum + getDurationSeconds(log), 0);
                    });
                });

                const weekLabels = weekKeys.map((weekKey, idx) => {
                    const d = new Date(weekKey);
                    return `W${idx + 1}`;
                });

                // Prepare all category series
                const allCategorySeries = sortedCategories.map(([catId, catData]) => ({
                    id: catId,
                    name: `${catData.icon} ${catData.name}`,
                    nameOnly: catData.name,
                    data: categoryByWeek[catId] || [],
                    color: catData.color,
                    icon: catData.icon,
                    time: categoryTotals[catId]?.time || 0
                })).filter(series => series.data.some(val => val > 0) || series.time > 0);

                // Initialize selected categories separately for each chart (first 3 by default)
                window.selectedCategoriesHistogram = new Set();
                window.selectedCategoriesLine = new Set();
                allCategorySeries.slice(0, 3).forEach(series => {
                    window.selectedCategoriesHistogram.add(series.id);
                    window.selectedCategoriesLine.add(series.id);
                });

                // Generate initial charts with selected categories
                const initialHistogramIds = Array.from(window.selectedCategoriesHistogram);
                const initialLineIds = Array.from(window.selectedCategoriesLine);
                
                const initialTotalTimeData = initialHistogramIds
                    .map(catId => {
                        const catData = categoryTotals[catId];
                        if (!catData) return null;
                        return {
                            value: catData.time,
                            label: catData.name,
                            color: catData.color
                        };
                    })
                    .filter(item => item !== null);

                const initialSelectedSeries = allCategorySeries
                    .filter(s => initialLineIds.includes(s.id))
                    .map(s => ({
                        name: s.nameOnly || s.name.replace(/^[^\w\s]+/, '').trim(),
                        data: s.data,
                        color: s.color
                    }));

                // Generate charts without outer containers
                const histogramInnerHtml = generateHistogramChart(initialTotalTimeData, initialTotalTimeData.map(d => d.label), '', false);
                const lineChartInnerHtml = generateLineChart(initialSelectedSeries, weekLabels, '', false);

                // Store data globally for updates
                window.monthChartData = {
                    allSeries: allCategorySeries,
                    labels: weekLabels,
                    weekLabels: weekLabels,
                    categoryTotals: categoryTotals
                };

                // Wrap both charts in a flex container to display side by side
                chartHtml += `
                    <div class="charts-row-container">
                        <div class="chart-container">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                <div class="chart-title" style="margin-bottom: 0;">📊 Total Time by Category (Month)</div>
                                ${generateCategoryDropdown('histogram', allCategorySeries)}
                            </div>
                            <div id="monthHistogramContainer">
                                ${histogramInnerHtml}
                            </div>
                        </div>
                        <div class="chart-container">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                <div class="chart-title" style="margin-bottom: 0;">📈 Category Trends by Week</div>
                                ${generateCategoryDropdown('line', allCategorySeries)}
                            </div>
                            <div id="monthLineChartContainer">
                                ${lineChartInnerHtml}
                            </div>
                        </div>
                    </div>
                `;
            } else if (range === 'year') {
                // Prepare data by month
                const byMonth = {};
                logsInRange.forEach(log => {
                    const end = getLogEndTimeMs(log);
                    const date = new Date(end);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    if (!byMonth[monthKey]) byMonth[monthKey] = [];
                    byMonth[monthKey].push(log);
                });

                const monthKeys = Object.keys(byMonth).sort();
                
                // Calculate category totals for the year
                const categoryTotals = {};
                logsInRange.forEach(log => {
                    if (!categoryTotals[log.category]) {
                        const catData = getAllCategories().find(c => c.id === log.category);
                        categoryTotals[log.category] = {
                            time: 0,
                            icon: catData?.icon || '📁',
                            name: catData?.name || log.category,
                            color: catData?.color || '#667eea'
                        };
                    }
                    categoryTotals[log.category].time += getDurationSeconds(log);
                });

                // Prepare category data by month
                const categoryByMonth = {};
                sortedCategories.forEach(([catId, catData]) => {
                    categoryByMonth[catId] = monthKeys.map(monthKey => {
                        const logs = byMonth[monthKey].filter(log => log.category === catId);
                        return logs.reduce((sum, log) => sum + getDurationSeconds(log), 0);
                    });
                });

                const monthLabels = monthKeys.map(monthKey => {
                    const [year, month] = monthKey.split('-');
                    return new Date(year, parseInt(month) - 1, 1).toLocaleDateString('en-US', { month: 'short' });
                });

                // Prepare all category series
                const allCategorySeries = sortedCategories.map(([catId, catData]) => ({
                    id: catId,
                    name: `${catData.icon} ${catData.name}`,
                    nameOnly: catData.name,
                    data: categoryByMonth[catId] || [],
                    color: catData.color,
                    icon: catData.icon,
                    time: categoryTotals[catId]?.time || 0
                })).filter(series => series.data.some(val => val > 0) || series.time > 0);

                // Initialize selected categories separately for each chart (first 3 by default)
                window.selectedCategoriesHistogram = new Set();
                window.selectedCategoriesLine = new Set();
                allCategorySeries.slice(0, 3).forEach(series => {
                    window.selectedCategoriesHistogram.add(series.id);
                    window.selectedCategoriesLine.add(series.id);
                });

                // Generate initial charts with selected categories
                const initialHistogramIds = Array.from(window.selectedCategoriesHistogram);
                const initialLineIds = Array.from(window.selectedCategoriesLine);
                
                const initialTotalTimeData = initialHistogramIds
                    .map(catId => {
                        const catData = categoryTotals[catId];
                        if (!catData) return null;
                        return {
                            value: catData.time,
                            label: catData.name,
                            color: catData.color
                        };
                    })
                    .filter(item => item !== null);

                const initialSelectedSeries = allCategorySeries
                    .filter(s => initialLineIds.includes(s.id))
                    .map(s => ({
                        name: s.nameOnly || s.name.replace(/^[^\w\s]+/, '').trim(),
                        data: s.data,
                        color: s.color
                    }));

                // Generate charts without outer containers
                const histogramInnerHtml = generateHistogramChart(initialTotalTimeData, initialTotalTimeData.map(d => d.label), '', false);
                const lineChartInnerHtml = generateLineChart(initialSelectedSeries, monthLabels, '', false);

                // Store data globally for updates
                window.yearChartData = {
                    allSeries: allCategorySeries,
                    labels: monthLabels,
                    monthLabels: monthLabels,
                    categoryTotals: categoryTotals
                };

                // Wrap both charts in a flex container to display side by side
                chartHtml += `
                    <div class="charts-row-container">
                        <div class="chart-container">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                <div class="chart-title" style="margin-bottom: 0;">📊 Total Time by Category (Year)</div>
                                ${generateCategoryDropdown('histogram', allCategorySeries)}
                            </div>
                            <div id="yearHistogramContainer">
                                ${histogramInnerHtml}
                            </div>
                        </div>
                        <div class="chart-container">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                <div class="chart-title" style="margin-bottom: 0;">📈 Category Trends by Month</div>
                                ${generateCategoryDropdown('line', allCategorySeries)}
                            </div>
                            <div id="yearLineChartContainer">
                                ${lineChartInnerHtml}
                            </div>
                        </div>
                    </div>
                `;
            }


            grid.innerHTML = chartHtml;
            if (summary) summary.innerHTML = '';
        }

        function getStatsRangeBounds(range) {
            // Get the selected date from statsDate input
            const statsDateInput = document.getElementById('statsDate');
            let baseDate;
            
            if (statsDateInput && statsDateInput.value) {
                const [y, m, d] = statsDateInput.value.split('-').map(Number);
                baseDate = new Date(y, m - 1, d);
            } else {
                baseDate = new Date();
                baseDate.setHours(0, 0, 0, 0);
            }
            
            const startOfDay = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate()).getTime();
            
            if (range === 'day') {
                return { startMs: startOfDay, endMs: startOfDay + 24 * 3600 * 1000 };
            }
            if (range === 'week') {
                const day = baseDate.getDay(); // 0 Sun - 6 Sat
                const diffToMonday = (day === 0 ? -6 : 1 - day); // Monday as start
                const start = new Date(baseDate);
                start.setDate(baseDate.getDate() + diffToMonday);
                start.setHours(0, 0, 0, 0);
                const startMs = start.getTime();
                return { startMs, endMs: startMs + 7 * 24 * 3600 * 1000 };
            }
            if (range === 'month') {
                const start = new Date(baseDate.getFullYear(), baseDate.getMonth(), 1);
                const next = new Date(baseDate.getFullYear(), baseDate.getMonth() + 1, 1);
                return { startMs: start.getTime(), endMs: next.getTime() };
            }
            if (range === 'year') {
                const start = new Date(baseDate.getFullYear(), 0, 1);
                const next = new Date(baseDate.getFullYear() + 1, 0, 1);
                return { startMs: start.getTime(), endMs: next.getTime() };
            }
            // all time
            return { startMs: -Infinity, endMs: Infinity };
        }

        function getLogEndTimeMs(log) {
            const end = Number(log.endTime);
            if (Number.isFinite(end)) return end;
            const d = Date.parse(log.date);
            return Number.isFinite(d) ? d : 0;
        }

        // Update logs view
        function updateLogsView() {
            const rangeSelect = document.getElementById('statsRange');
            const range = rangeSelect ? rangeSelect.value : 'day';
            const { startMs, endMs: rangeEndMs } = getStatsRangeBounds(range);

            // Filter logs by selected range using end time
            const logs = timeLogs.filter(log => {
                const end = getLogEndTimeMs(log);
                return Number.isFinite(end) && end >= startMs && end < rangeEndMs;
            });

            // Update category stats
            const categoryTotals = {};
            
            logs.forEach(log => {
                if (!categoryTotals[log.category]) {
                    categoryTotals[log.category] = {
                        time: 0,
                        name: log.categoryName,
                        color: log.categoryColor,
                        icon: log.categoryIcon,
                    };
                }
                categoryTotals[log.category].time += getDurationSeconds(log);
            });

            const maxTime = Math.max(...Object.values(categoryTotals).map(d => d.time), 1);
            const categoryBars = document.getElementById('categoryBars');
            
            if (Object.keys(categoryTotals).length === 0) {
                categoryBars.innerHTML = '<div class="empty-state">No data yet. Start tracking your time!</div>';
            } else {
                categoryBars.innerHTML = Object.entries(categoryTotals)
                    .sort((a, b) => b[1].time - a[1].time)
                    .map(([categoryId, data]) => `
                        <div class="category-bar-item" onclick="openCategoryModal('${categoryId}')">
                            <div class="category-bar-header">
                                <span>${data.icon} ${data.name}</span>
                                <span>${formatTime(data.time)}</span>
                            </div>
                            <div class="category-bar">
                                <div class="category-bar-fill" style="width: ${(data.time / maxTime) * 100}%; background-color: ${data.color};"></div>
                            </div>
                            <div style="font-size: 0.8rem; color: #6b7280; margin-top: 6px;">Click to view & edit details</div>
                        </div>
                    `).join('');
            }
            
            // Also update Overview section
            renderOverview();
        }

        // Delete log
        function deleteLog(id) {
            if (confirm('Are you sure you want to delete this log entry?')) {
                timeLogs = timeLogs.filter(log => log.id !== id);
                saveLogs();
                updateLogsView();
            }
        }

        // Show prompt to add custom category
        function showAddCategoryPrompt() {
            if (activeTimer) {
                alert('Cannot add category while timer is running');
                return;
            }
            
            const name = prompt('Enter category name:');
            
            if (!name || !name.trim()) {
                return; // User cancelled or entered nothing
            }
            
            const trimmedName = name.trim();
            
            // Check if name already exists
            const allCategories = getAllCategories();
            if (allCategories.some(c => c.name.toLowerCase() === trimmedName.toLowerCase())) {
                alert('A category with this name already exists');
                return;
            }
            
            // Default icon and color
            const defaultIcons = ['📝', '⭐', '🎯', '💡', '🔖', '📌', '🏷️', '✨'];
            const defaultColors = ['#6b7280', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316', '#84cc16', '#6366f1', '#10b981'];
            
            // Use a simple hash to assign consistent icon/color based on name
            const hash = trimmedName.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const icon = defaultIcons[hash % defaultIcons.length];
            const color = defaultColors[hash % defaultColors.length];
            
            const newCategory = {
                id: 'custom_' + Date.now(),
                name: trimmedName,
                icon: icon,
                color: color,
                isCustom: true
            };
            
            customCategories.push(newCategory);
            saveCustomCategories();
            
            // Re-render categories
            renderCategories();
            updateManualCategoryDropdown();
        }

        // Add manual entry
        function addManualEntry() {
            const startHour = Number(document.getElementById('manualStartHour')?.value);
            const startMinute = Number(document.getElementById('manualStartMinute')?.value);
            const endHour = Number(document.getElementById('manualEndHour')?.value);
            const endMinute = Number(document.getElementById('manualEndMinute')?.value);
            const manualCategoryId = document.getElementById('manualCategory').value;
            let manualSubcategory = document.getElementById('manualSubcategory')?.value || null;
            if (manualSubcategory === '__add_new__') manualSubcategory = null;

            if (![startHour, startMinute, endHour, endMinute].every(Number.isFinite)) {
                alert(t('pleaseSelectStartEndTime'));
                return;
            }

            const base = new Date();
            base.setSeconds(0, 0);
            const startTime = new Date(base.getFullYear(), base.getMonth(), base.getDate(), startHour, startMinute, 0, 0).getTime();
            let endTime = new Date(base.getFullYear(), base.getMonth(), base.getDate(), endHour, endMinute, 0, 0).getTime();
            // If end is before start, assume it crosses midnight to next day
            if (endTime <= startTime) {
                endTime += 24 * 3600 * 1000;
            }

            const totalSeconds = Math.max(0, Math.floor((endTime - startTime) / 1000));
            if (totalSeconds === 0) {
                alert(t('pleaseEnsureEndAfterStart'));
                return;
            }

            if (!manualCategoryId) {
                alert(t('pleaseSelectCategoryForEntry'));
                return;
            }
            
            const category = getAllCategories().find(c => c.id === manualCategoryId);
            if (!category) {
                alert(t('invalidCategory'));
                return;
            }
            
            const newLog = {
                id: Date.now(),
                category: manualCategoryId,
                categoryName: category.name,
                categoryColor: category.color,
                categoryIcon: category.icon,
                subcategory: manualSubcategory || null,
                duration: totalSeconds,
                startTime: startTime,
                endTime: endTime,
                date: new Date(endTime).toISOString(),
                isManualEntry: true,
            };
            
            timeLogs.unshift(newLog);
            saveLogs();
            
            // Reset form
            initManualTimeSelects();
            document.getElementById('manualCategory').value = selectedCategory; // Reset to current selected category
            updateManualSubcategoryDropdown();
            
            updateLogsView();
            renderGoalsProgress();
            
            // Show success message
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '✓ Added!';
            btn.style.background = '#10b981';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 2000);
        }
        
        // Update manual entry category dropdown
        function updateManualCategoryDropdown() {
            const select = document.getElementById('manualCategory');
            if (!select) return;
            
            const allCategories = getAllCategories();
            select.innerHTML = allCategories.map(category => 
                `<option value="${category.id}" ${category.id === selectedCategory ? 'selected' : ''}>${category.icon} ${category.name}</option>`
            ).join('');
            
            updateManualSubcategoryDropdown();
        }

        function updateManualSubcategoryDropdown() {
            const catSelect = document.getElementById('manualCategory');
            const subSelect = document.getElementById('manualSubcategory');
            if (!catSelect || !subSelect) return;
            
            const categoryId = catSelect.value;
            const subs = getAllSubcategories(categoryId);
            
            subSelect.innerHTML = '<option value="">-- No subcategory --</option>' + 
                subs.map(sub => `<option value="${sub}">${sub}</option>`).join('') +
                '<option value="__add_new__">➕ Add new...</option>';
        }

        function handleManualSubcategoryChange() {
            const catSelect = document.getElementById('manualCategory');
            const subSelect = document.getElementById('manualSubcategory');
            if (!catSelect || !subSelect) return;
            
            if (subSelect.value === '__add_new__') {
                const newSub = prompt('Enter new subcategory name:');
                if (newSub && newSub.trim()) {
                    const categoryId = catSelect.value;
                    if (addCustomSubcategory(categoryId, newSub.trim())) {
                        updateManualSubcategoryDropdown();
                        subSelect.value = newSub.trim();
                    } else {
                        alert('Subcategory already exists or is invalid.');
                        subSelect.value = '';
                    }
                } else {
                    subSelect.value = '';
                }
            }
        }

        // Delete custom category
        function deleteCategory(categoryId) {
            // Check if category is used in any logs
            const isUsed = timeLogs.some(log => log.category === categoryId);
            const isDefault = DEFAULT_CATEGORIES.some(c => c.id === categoryId);
            const category = getAllCategories().find(c => c.id === categoryId);
            
            let message = `Delete category "${category?.name || categoryId}"?`;
            if (isUsed) {
                message += '\n\nThis category is used in some time logs. Those logs will show as "Unknown Category".';
            }
            if (isDefault) {
                message += '\n\nThis is a default category. You can restore it later using "Reset to Defaults".';
            }
            
            if (!confirm(message)) {
                return;
            }
            
            if (isDefault) {
                // Mark default as deleted
                if (!deletedDefaults.includes(categoryId)) {
                    deletedDefaults.push(categoryId);
                    saveDeletedDefaults();
                }
            } else {
                // Remove custom category
                customCategories = customCategories.filter(c => c.id !== categoryId);
                saveCustomCategories();
            }
            
            // If this was the selected category, switch to first available
            if (selectedCategory === categoryId) {
                const allCategories = getAllCategories();
                if (allCategories.length > 0) {
                    selectedCategory = allCategories[0].id;
                }
            }
            
            renderCategories();
            updateManualCategoryDropdown();
        }

        // Edit category name
        function editCategory(categoryId) {
            const category = getAllCategories().find(c => c.id === categoryId);
            if (!category) return;
            
            const newName = prompt('Edit category name:', category.name);
            if (!newName || !newName.trim() || newName.trim() === category.name) {
                return;
            }
            
            const trimmed = newName.trim();
            const isDefault = DEFAULT_CATEGORIES.some(c => c.id === categoryId);
            
            if (isDefault) {
                // Store modification for default category
                if (!modifiedDefaults[categoryId]) {
                    modifiedDefaults[categoryId] = {};
                }
                modifiedDefaults[categoryId].name = trimmed;
                saveModifiedDefaults();
            } else {
                // Update custom category
                const idx = customCategories.findIndex(c => c.id === categoryId);
                if (idx !== -1) {
                    customCategories[idx].name = trimmed;
                    saveCustomCategories();
                }
            }
            
            // Update logs to reflect the new name
            timeLogs.forEach(log => {
                if (log.category === categoryId) {
                    log.categoryName = trimmed;
                }
            });
            saveLogs();
            
            renderCategories();
            updateManualCategoryDropdown();
            updateLogsView();
        }

        // Keep old function name for backward compatibility
        function deleteCustomCategory(categoryId) {
            deleteCategory(categoryId);
        }

        // Category Modal Functions
        function openCategoryModal(categoryId) {
            const modal = document.getElementById('categoryModal');
            const title = document.getElementById('categoryModalTitle');
            const body = document.getElementById('categoryModalBody');
            
            const category = getAllCategories().find(c => c.id === categoryId);
            const categoryLogs = timeLogs.filter(log => log.category === categoryId);
            
            if (!category) {
                title.textContent = 'Unknown Category';
            } else {
                title.textContent = `${category.icon} ${category.name} - Details`;
            }
            
            if (categoryLogs.length === 0) {
                body.innerHTML = '<div class="empty-state">No logs for this category.</div>';
            } else {
                // Sort by end time descending (most recent first)
                const sortedLogs = [...categoryLogs].sort((a, b) => getLogEndTimeMs(b) - getLogEndTimeMs(a));
                
                body.innerHTML = sortedLogs.map(log => {
                    const startDate = new Date(log.startTime);
                    const endDate = new Date(log.endTime);
                    const dateStr = startDate.toLocaleDateString();
                    const startH = startDate.getHours();
                    const startM = startDate.getMinutes();
                    const endH = endDate.getHours();
                    const endM = endDate.getMinutes();
                    const dur = formatTime(getDurationSeconds(log));
                    
                    // Build hour options
                    let hourOptions = '';
                    for (let h = 0; h < 24; h++) {
                        hourOptions += `<option value="${h}" ${h === startH ? 'selected' : ''}>${pad2(h)}</option>`;
                    }
                    let endHourOptions = '';
                    for (let h = 0; h < 24; h++) {
                        endHourOptions += `<option value="${h}" ${h === endH ? 'selected' : ''}>${pad2(h)}</option>`;
                    }
                    
                    // Build minute options (5-min steps)
                    let minOptions = '';
                    for (let m = 0; m < 60; m += 5) {
                        const selected = (m === Math.floor(startM / 5) * 5) ? 'selected' : '';
                        minOptions += `<option value="${m}" ${selected}>${pad2(m)}</option>`;
                    }
                    let endMinOptions = '';
                    for (let m = 0; m < 60; m += 5) {
                        const selected = (m === Math.floor(endM / 5) * 5) ? 'selected' : '';
                        endMinOptions += `<option value="${m}" ${selected}>${pad2(m)}</option>`;
                    }
                    
                    // Build category options
                    const allCats = getAllCategories();
                    let catOptions = allCats.map(c => 
                        `<option value="${c.id}" ${c.id === log.category ? 'selected' : ''}>${c.icon} ${c.name}</option>`
                    ).join('');
                    
                    // Build subcategory options
                    const subs = getAllSubcategories(log.category);
                    let subOptions = '<option value="">-- No subcategory --</option>' + 
                        subs.map(s => `<option value="${s}" ${s === log.subcategory ? 'selected' : ''}>${s}</option>`).join('') +
                        '<option value="__add_new__">➕ Add new...</option>';
                    
                    const subLabel = log.subcategory ? ` › ${log.subcategory}` : '';
                    
                    return `
                        <div class="edit-log-item" id="editLog_${log.id}">
                            <div style="font-size: 0.85rem; color: #6b7280; margin-bottom: 10px;">
                                ${dateStr}${subLabel} · Duration: ${dur}
                            </div>
                            <div class="edit-log-row">
                                <label>Category</label>
                                <select id="editCat_${log.id}" onchange="updateEditSubcategoryOptions(${log.id})">${catOptions}</select>
                            </div>
                            <div class="edit-log-row">
                                <label>Subcategory</label>
                                <select id="editSub_${log.id}" onchange="handleEditSubcategoryChange(${log.id}, '${categoryId}')">${subOptions}</select>
                            </div>
                            <div class="edit-log-row">
                                <label>Start</label>
                                <select id="editStartH_${log.id}">${hourOptions}</select>
                                <span>:</span>
                                <select id="editStartM_${log.id}">${minOptions}</select>
                            </div>
                            <div class="edit-log-row">
                                <label>End</label>
                                <select id="editEndH_${log.id}">${endHourOptions}</select>
                                <span>:</span>
                                <select id="editEndM_${log.id}">${endMinOptions}</select>
                            </div>
                            <div class="edit-log-actions">
                                <button class="btn-delete-log" onclick="deleteLogFromModal(${log.id}, '${categoryId}')">🗑️ Delete</button>
                                <button class="btn-save-log" onclick="saveLogFromModal(${log.id}, '${categoryId}')">💾 Save Changes</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            modal.classList.remove('hidden');
        }
        
        function closeCategoryModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('categoryModal').classList.add('hidden');
            updateLogsView(); // Refresh stats after editing
        }

        // Management Modal Functions
        function openManagementModal() {
            const modal = document.getElementById('managementModal');
            modal.classList.add('active');
            renderManagementContent();
        }

        function closeManagementModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('managementModal').classList.remove('active');
            renderCategories();
            updateManualCategoryDropdown();
        }

        function renderManagementContent() {
            const body = document.getElementById('managementBody');
            const allCategories = getAllCategories();
            
            let html = `
                <div class="management-section">
                    <h3>📁 Categories</h3>
                    <div class="management-list" id="mgmtCategoryList">
            `;
            
            allCategories.forEach(cat => {
                const subs = getAllSubcategories(cat.id);
                const customSubs = customSubcategories[cat.id] || [];
                const isDefault = DEFAULT_CATEGORIES.some(c => c.id === cat.id);
                
                html += `
                    <div class="management-item-wrapper">
                        <div class="management-item">
                            <div class="management-item-info">
                                <span class="management-item-icon">${cat.icon}</span>
                                <span class="management-item-name">${cat.name}</span>
                                ${isDefault ? '<span class="management-item-badge">Default</span>' : '<span class="management-item-badge" style="background:#dcfce7;color:#16a34a;">Custom</span>'}
                            </div>
                            <div class="management-item-actions">
                                <button class="subcategory-expand" onclick="toggleSubcategoryList('${cat.id}')">
                                    ${subs.length} subs ▼
                                </button>
                                <button class="mgmt-edit-btn" onclick="mgmtEditCategory('${cat.id}')">✏️ Edit</button>
                                <button class="mgmt-delete-btn" onclick="mgmtDeleteCategory('${cat.id}')">🗑️ Delete</button>
                            </div>
                        </div>
                        <div class="subcategory-list" id="subList_${cat.id}">
                            ${subs.map(sub => {
                                const isCustomSub = customSubs.includes(sub);
                                return `
                                    <div class="subcategory-item">
                                        <span class="subcategory-item-name">
                                            ${sub}
                                            ${isCustomSub ? '<span class="subcategory-item-badge">Custom</span>' : ''}
                                        </span>
                                        <div class="management-item-actions">
                                            <button class="mgmt-edit-btn" onclick="mgmtEditSubcategory('${cat.id}', '${sub.replace(/'/g, "\\'")}', ${isCustomSub})">✏️</button>
                                            <button class="mgmt-delete-btn" onclick="mgmtDeleteSubcategory('${cat.id}', '${sub.replace(/'/g, "\\'")}', ${isCustomSub})">🗑️</button>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                            <button class="mgmt-add-btn" onclick="mgmtAddSubcategory('${cat.id}')" style="margin-top: 8px;">
                                ➕ Add Subcategory
                            </button>
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    <button class="mgmt-add-btn" onclick="mgmtAddCategory()" style="margin-top: 12px;">
                        ➕ Add New Category
                    </button>
                </div>
                
                <div class="management-section reset-section">
                    <button class="reset-btn" onclick="resetToDefaults(); renderManagementContent();">
                        🔄 Reset to Default Categories
                    </button>
                </div>
            `;
            
            body.innerHTML = html;
        }

        function toggleSubcategoryList(categoryId) {
            const list = document.getElementById('subList_' + categoryId);
            if (list) {
                list.classList.toggle('expanded');
            }
        }

        function mgmtAddCategory() {
            const name = prompt('Enter new category name:');
            if (name && name.trim()) {
                const icon = prompt('Enter an emoji icon for the category:', '📌') || '📌';
                const id = 'custom_' + Date.now();
                const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                customCategories.push({
                    id,
                    name: name.trim(),
                    color,
                    icon,
                    isCustom: true,
                    subcategories: []
                });
                saveCustomCategories();
                renderManagementContent();
            }
        }

        function mgmtEditCategory(categoryId) {
            editCategory(categoryId);
            renderManagementContent();
        }

        function mgmtDeleteCategory(categoryId) {
            deleteCategory(categoryId);
            renderManagementContent();
        }

        function mgmtAddSubcategory(categoryId) {
            const name = prompt('Enter new subcategory name:');
            if (name && name.trim()) {
                if (addCustomSubcategory(categoryId, name.trim())) {
                    renderManagementContent();
                    // Expand the list to show the new item
                    const list = document.getElementById('subList_' + categoryId);
                    if (list) list.classList.add('expanded');
                } else {
                    alert('Subcategory already exists or is invalid.');
                }
            }
        }

        function mgmtEditSubcategory(categoryId, subName, isCustom) {
            const newName = prompt('Edit subcategory name:', subName);
            if (newName && newName.trim() && newName.trim() !== subName) {
                const trimmed = newName.trim();
                
                // Check if new name already exists
                const allSubs = getAllSubcategories(categoryId);
                if (allSubs.includes(trimmed)) {
                    alert('A subcategory with this name already exists.');
                    return;
                }
                
                if (isCustom) {
                    // Update custom subcategory
                    if (customSubcategories[categoryId]) {
                        const idx = customSubcategories[categoryId].indexOf(subName);
                        if (idx !== -1) {
                            customSubcategories[categoryId][idx] = trimmed;
                            saveCustomSubcategories();
                        }
                    }
                } else {
                    // For predefined subcategory, we replace it by:
                    // 1. Adding a custom one with the new name
                    // 2. Marking the old one as "hidden" by storing in a hidden list
                    if (!customSubcategories[categoryId]) {
                        customSubcategories[categoryId] = [];
                    }
                    customSubcategories[categoryId].push(trimmed);
                    saveCustomSubcategories();
                    
                    // Store the hidden predefined subcategory
                    let hiddenSubs = JSON.parse(localStorage.getItem('hiddenSubcategories') || '{}');
                    if (!hiddenSubs[categoryId]) {
                        hiddenSubs[categoryId] = [];
                    }
                    if (!hiddenSubs[categoryId].includes(subName)) {
                        hiddenSubs[categoryId].push(subName);
                    }
                    localStorage.setItem('hiddenSubcategories', JSON.stringify(hiddenSubs));
                }
                
                // Update existing logs
                timeLogs.forEach(log => {
                    if (log.category === categoryId && log.subcategory === subName) {
                        log.subcategory = trimmed;
                    }
                });
                saveLogs();
                
                // Update selected subcategory if it was the one being edited
                if (selectedSubcategory === subName) {
                    selectedSubcategory = trimmed;
                }
            }
            renderManagementContent();
            renderCategories();
        }

        function mgmtDeleteSubcategory(categoryId, subName, isCustom) {
            if (!confirm(`Delete subcategory "${subName}"?`)) {
                return;
            }
            
            if (isCustom) {
                // Delete custom subcategory
                if (customSubcategories[categoryId]) {
                    customSubcategories[categoryId] = customSubcategories[categoryId].filter(s => s !== subName);
                    saveCustomSubcategories();
                }
            } else {
                // Hide predefined subcategory
                let hiddenSubs = JSON.parse(localStorage.getItem('hiddenSubcategories') || '{}');
                if (!hiddenSubs[categoryId]) {
                    hiddenSubs[categoryId] = [];
                }
                if (!hiddenSubs[categoryId].includes(subName)) {
                    hiddenSubs[categoryId].push(subName);
                }
                localStorage.setItem('hiddenSubcategories', JSON.stringify(hiddenSubs));
            }
            
            // Reset selected subcategory if it was the one being deleted
            if (selectedSubcategory === subName) {
                selectedSubcategory = null;
            }
            
            renderManagementContent();
            renderCategories();
        }
        
        function updateEditSubcategoryOptions(logId) {
            const catSelect = document.getElementById(`editCat_${logId}`);
            const subSelect = document.getElementById(`editSub_${logId}`);
            if (!catSelect || !subSelect) return;
            
            const categoryId = catSelect.value;
            const subs = getAllSubcategories(categoryId);
            
            subSelect.innerHTML = '<option value="">-- No subcategory --</option>' + 
                subs.map(s => `<option value="${s}">${s}</option>`).join('') +
                '<option value="__add_new__">➕ Add new...</option>';
        }

        function handleEditSubcategoryChange(logId, originalCategoryId) {
            const catSelect = document.getElementById(`editCat_${logId}`);
            const subSelect = document.getElementById(`editSub_${logId}`);
            if (!catSelect || !subSelect) return;
            
            if (subSelect.value === '__add_new__') {
                const newSub = prompt('Enter new subcategory name:');
                if (newSub && newSub.trim()) {
                    const categoryId = catSelect.value;
                    if (addCustomSubcategory(categoryId, newSub.trim())) {
                        updateEditSubcategoryOptions(logId);
                        subSelect.value = newSub.trim();
                    } else {
                        alert('Subcategory already exists or is invalid.');
                        subSelect.value = '';
                    }
                } else {
                    subSelect.value = '';
                }
            }
        }
        
        function saveLogFromModal(logId, categoryId) {
            const log = timeLogs.find(l => l.id === logId);
            if (!log) return;
            
            const newCatId = document.getElementById(`editCat_${logId}`).value;
            let newSubcategory = document.getElementById(`editSub_${logId}`)?.value || null;
            if (newSubcategory === '__add_new__') newSubcategory = null;
            const startH = parseInt(document.getElementById(`editStartH_${logId}`).value);
            const startM = parseInt(document.getElementById(`editStartM_${logId}`).value);
            const endH = parseInt(document.getElementById(`editEndH_${logId}`).value);
            const endM = parseInt(document.getElementById(`editEndM_${logId}`).value);
            
            // Get the original date (day) from the log
            const originalDate = new Date(log.startTime);
            const year = originalDate.getFullYear();
            const month = originalDate.getMonth();
            const day = originalDate.getDate();
            
            // Build new start/end times
            let newStart = new Date(year, month, day, startH, startM, 0, 0);
            let newEnd = new Date(year, month, day, endH, endM, 0, 0);
            
            // If end is before start, assume it crosses midnight
            if (newEnd <= newStart) {
                newEnd.setDate(newEnd.getDate() + 1);
            }
            
            const newCategory = getAllCategories().find(c => c.id === newCatId);
            if (newCategory) {
                log.category = newCatId;
                log.categoryName = newCategory.name;
                log.categoryColor = newCategory.color;
                log.categoryIcon = newCategory.icon;
            }
            
            log.subcategory = newSubcategory || null;
            log.startTime = newStart.getTime();
            log.endTime = newEnd.getTime();
            log.duration = Math.floor((log.endTime - log.startTime) / 1000);
            
            saveLogs();
            
            // Show success feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '✓ Saved!';
            btn.style.background = '#059669';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
                // Refresh modal to show updated data
                openCategoryModal(categoryId);
            }, 1000);
        }
        
        function deleteLogFromModal(logId, categoryId) {
            if (!confirm('Delete this log entry?')) return;
            
            timeLogs = timeLogs.filter(log => log.id !== logId);
            saveLogs();
            
            // Check if there are still logs for this category
            const remainingLogs = timeLogs.filter(log => log.category === categoryId);
            if (remainingLogs.length === 0) {
                closeCategoryModal();
            } else {
                openCategoryModal(categoryId); // Refresh modal
            }
        }

        // ============ FIREBASE & AUTH ============
        
        let firebaseApp = null;
        let firebaseAuth = null;
        let firebaseDb = null;
        let currentUser = null;
        let unsubscribeSync = null;

        function initFirebase() {
            const savedConfig = localStorage.getItem('firebaseConfig');
            if (!savedConfig) return false;

            try {
                const config = JSON.parse(savedConfig);
                if (!firebase.apps.length) {
                    firebaseApp = firebase.initializeApp(config);
                } else {
                    firebaseApp = firebase.apps[0];
                }
                firebaseAuth = firebase.auth();
                firebaseDb = firebase.firestore();

                // Listen for auth state changes
                firebaseAuth.onAuthStateChanged(user => {
                    currentUser = user;
                    updateAuthUI();
                    if (user) {
                        setupRealtimeSync();
                    } else {
                        if (unsubscribeSync) {
                            unsubscribeSync();
                            unsubscribeSync = null;
                        }
                    }
                });

                return true;
            } catch (err) {
                console.error('Firebase init error:', err);
                return false;
            }
        }

        function updateAuthUI() {
            const btn = document.getElementById('authBtn');
            const status = document.getElementById('syncStatus');
            
            if (currentUser) {
                btn.innerHTML = '👤 ' + (currentUser.email?.split('@')[0] || 'Account');
                btn.classList.add('logged-in');
                status.innerHTML = '☁️ Auto-sync enabled';
            } else {
                btn.innerHTML = '👤 Login';
                btn.classList.remove('logged-in');
                status.innerHTML = '';
            }
        }

        function openAuthModal() {
            document.getElementById('authModal').classList.add('active');
            if (currentUser) {
                document.getElementById('authLoginView').style.display = 'none';
                document.getElementById('authAccountView').style.display = 'block';
                document.getElementById('accountEmail').textContent = currentUser.email;
                document.getElementById('authTitle').textContent = '👤 My Account';
                
                const lastSync = localStorage.getItem('lastCloudSync');
                if (lastSync) {
                    document.getElementById('lastSyncTime').textContent = 
                        'Last synced: ' + new Date(lastSync).toLocaleString();
                }
            } else {
                document.getElementById('authLoginView').style.display = 'block';
                document.getElementById('authAccountView').style.display = 'none';
                document.getElementById('authTitle').textContent = '👤 Login / Sign Up';
            }
        }

        function closeAuthModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('authModal').classList.remove('active');
        }

        function switchAuthTab(tab) {
            const tabs = document.querySelectorAll('.auth-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            const submitBtn = document.getElementById('authSubmitBtn');
            submitBtn.textContent = tab === 'login' ? 'Login' : 'Sign Up';
        }

        async function handleAuthSubmit(event) {
            event.preventDefault();
            
            if (!firebaseAuth) {
                alert('Please configure Firebase first. Click the setup info below.');
                return;
            }

            const email = document.getElementById('authEmail').value;
            const password = document.getElementById('authPassword').value;
            const isLogin = document.getElementById('authSubmitBtn').textContent === 'Login';

            try {
                if (isLogin) {
                    await firebaseAuth.signInWithEmailAndPassword(email, password);
                } else {
                    await firebaseAuth.createUserWithEmailAndPassword(email, password);
                }
                closeAuthModal();
                syncToCloud();
            } catch (err) {
                alert('Error: ' + err.message);
            }
        }

        async function signInWithGoogle() {
            if (!firebaseAuth) {
                alert('Please configure Firebase first. Click the setup info below.');
                return;
            }

            try {
                const provider = new firebase.auth.GoogleAuthProvider();
                await firebaseAuth.signInWithPopup(provider);
                closeAuthModal();
                syncToCloud();
            } catch (err) {
                alert('Error: ' + err.message);
            }
        }

        async function logoutUser() {
            if (firebaseAuth) {
                await firebaseAuth.signOut();
            }
            closeAuthModal();
        }

        function showFirebaseConfig() {
            closeAuthModal();
            document.getElementById('firebaseConfigModal').classList.add('active');
            
            const saved = localStorage.getItem('firebaseConfig');
            if (saved) {
                document.getElementById('firebaseConfigInput').value = saved;
            }
        }

        function closeFirebaseConfig(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('firebaseConfigModal').classList.remove('active');
        }

        function saveFirebaseConfig() {
            const input = document.getElementById('firebaseConfigInput').value.trim();
            
            try {
                const config = JSON.parse(input);
                if (!config.apiKey || !config.projectId) {
                    throw new Error('Missing required fields');
                }
                
                localStorage.setItem('firebaseConfig', JSON.stringify(config));
                
                if (initFirebase()) {
                    alert('✅ Firebase configured successfully!\n\nYou can now login to enable automatic sync.');
                    closeFirebaseConfig();
                    openAuthModal();
                } else {
                    alert('❌ Failed to initialize Firebase. Please check your config.');
                }
            } catch (err) {
                alert('❌ Invalid configuration. Please paste a valid JSON object.\n\n' + err.message);
            }
        }

        async function syncToCloud() {
            if (!currentUser || !firebaseDb) {
                alert('Please login first to sync to cloud.');
                return;
            }

            const status = document.getElementById('syncStatus');
            status.innerHTML = '🔄 Syncing...';

            try {
                const data = getAllData();
                await firebaseDb.collection('users').doc(currentUser.uid).set({
                    data: data,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });

                localStorage.setItem('lastCloudSync', new Date().toISOString());
                status.innerHTML = '✅ Synced!';
                
                setTimeout(() => {
                    status.innerHTML = '☁️ Auto-sync enabled';
                }, 2000);

                // Update last sync time in modal if open
                const lastSyncEl = document.getElementById('lastSyncTime');
                if (lastSyncEl) {
                    lastSyncEl.textContent = 'Last synced: ' + new Date().toLocaleString();
                }
            } catch (err) {
                console.error('Sync error:', err);
                status.innerHTML = '❌ Sync failed';
            }
        }

        async function loadFromCloud() {
            if (!currentUser || !firebaseDb) return;

            try {
                const doc = await firebaseDb.collection('users').doc(currentUser.uid).get();
                if (doc.exists && doc.data().data) {
                    const cloudData = doc.data().data;
                    
                    // Check if cloud data is newer
                    const localSync = localStorage.getItem('lastCloudSync');
                    const cloudTime = doc.data().updatedAt?.toDate();
                    
                    if (!localSync || (cloudTime && new Date(cloudTime) > new Date(localSync))) {
                        // Cloud is newer, merge data
                        processImportedData(cloudData);
                    }
                }
            } catch (err) {
                console.error('Load from cloud error:', err);
            }
        }

        function setupRealtimeSync() {
            if (!currentUser || !firebaseDb) return;

            // First load from cloud
            loadFromCloud();

            // Then listen for changes
            unsubscribeSync = firebaseDb.collection('users').doc(currentUser.uid)
                .onSnapshot(doc => {
                    if (doc.exists && doc.data().data) {
                        const cloudData = doc.data().data;
                        const localSync = localStorage.getItem('lastCloudSync');
                        const cloudTime = doc.data().updatedAt?.toDate();
                        
                        // Only update if cloud is newer and not our own update
                        if (cloudTime && localSync && new Date(cloudTime) > new Date(localSync)) {
                            console.log('Cloud data updated, syncing...');
                            processImportedData(cloudData);
                            localStorage.setItem('lastCloudSync', cloudTime.toISOString());
                        }
                    }
                });
        }

        // Auto-sync when data changes
        function autoSyncToCloud() {
            if (currentUser && firebaseDb) {
                // Debounce sync
                clearTimeout(window.syncTimeout);
                window.syncTimeout = setTimeout(() => {
                    syncToCloud();
                }, 2000);
            }
        }

        // Override save functions to trigger auto-sync
        const originalSaveLogs = saveLogs;
        saveLogs = function() {
            originalSaveLogs();
            autoSyncToCloud();
        };

        const originalSaveCustomCategories = saveCustomCategories;
        saveCustomCategories = function() {
            originalSaveCustomCategories();
            autoSyncToCloud();
        };

        const originalSaveCustomSubcategories = saveCustomSubcategories;
        saveCustomSubcategories = function() {
            originalSaveCustomSubcategories();
            autoSyncToCloud();
        };

        // ============ SYNC FUNCTIONS ============
        
        function openSyncModal() {
            updateSyncModalTranslations();
            document.getElementById('syncModal').classList.add('active');
        }

        function updateSyncModalTranslations() {
            const syncTitle = document.querySelector('#syncModal h2');
            if (syncTitle) syncTitle.textContent = `🔄 ${t('syncDataAcrossDevices')}`;
            
            const exportSection = document.querySelector('#syncModal h3');
            if (exportSection && exportSection.textContent.includes('Export')) {
                const sections = document.querySelectorAll('#syncModal .sync-section');
                if (sections.length >= 4) {
                    sections[0].querySelector('h3').textContent = `📤 ${t('exportData')}`;
                    sections[0].querySelector('p').textContent = t('exportDataDesc');
                    sections[0].querySelector('button').textContent = `📥 ${t('downloadDataFile')}`;
                    
                    sections[1].querySelector('h3').textContent = `📥 ${t('importData')}`;
                    sections[1].querySelector('p').textContent = t('importDataDesc');
                    sections[1].querySelector('button').textContent = `📤 ${t('uploadDataFile')}`;
                    
                    const divider = document.querySelector('.sync-divider span');
                    if (divider) divider.textContent = t('orQuickSync');
                    
                    sections[2].querySelector('h3').textContent = `📋 ${t('copySyncCode')}`;
                    sections[2].querySelector('p').textContent = t('copySyncCodeDesc');
                    sections[2].querySelector('button').textContent = `📋 ${t('copySyncCode')}`;
                    
                    sections[3].querySelector('h3').textContent = `📝 ${t('pasteSyncCode')}`;
                    sections[3].querySelector('p').textContent = t('pasteSyncCodeDesc');
                    const textarea = sections[3].querySelector('textarea');
                    if (textarea) textarea.placeholder = t('pasteSyncCodePlaceholder');
                    sections[3].querySelector('button').textContent = `✅ ${t('importFromCode')}`;
                }
            }
            
            const syncTip = document.querySelector('.sync-info p');
            if (syncTip) {
                const strong = syncTip.querySelector('strong');
                const tipText = t('syncTip');
                syncTip.innerHTML = `💡 <strong>${strong ? strong.textContent : 'Tip'}:</strong> ${tipText.replace(/^[^:]+:\s*/, '')}`;
            }
        }

        function closeSyncModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('syncModal').classList.remove('active');
        }

        // Language Functions
        function loadLanguage() {
            const saved = localStorage.getItem('appLanguage');
            if (saved && (saved === 'en' || saved === 'zh')) {
                currentLanguage = saved;
            }
            updateUI();
        }

        function saveLanguage() {
            localStorage.setItem('appLanguage', currentLanguage);
        }

        function openLanguageModal() {
            const modal = document.getElementById('languageModal');
            modal.classList.add('active');
            updateLanguageModal();
        }

        function closeLanguageModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('languageModal').classList.remove('active');
        }

        function setLanguage(lang) {
            if (lang !== 'en' && lang !== 'zh') return;
            currentLanguage = lang;
            saveLanguage();
            updateUI();
            updateLanguageModal();
            closeLanguageModal();
        }

        function updateLanguageModal() {
            document.querySelectorAll('.language-option').forEach(option => {
                option.classList.remove('selected');
            });
            const selectedOption = document.getElementById(`lang-${currentLanguage}`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
            }
        }

        function updateUI() {
            const t = translations[currentLanguage];
            if (!t) return;

            // Update header buttons
            const authBtn = document.getElementById('authBtn');
            if (authBtn) authBtn.textContent = `👤 ${t.login}`;
            
            const syncBtn = document.querySelector('.sync-btn');
            if (syncBtn) syncBtn.textContent = `🔄 ${t.sync}`;
            
            const langBtn = document.querySelector('.lang-btn');
            if (langBtn) langBtn.textContent = `🌐 ${t.language}`;

            // Update timer buttons
            const startBtn = document.getElementById('startBtn');
            if (startBtn) startBtn.textContent = `▶ ${t.start}`;
            
            const stopBtn = document.getElementById('stopBtn');
            if (stopBtn) stopBtn.textContent = `⏹ ${t.stop}`;
            
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) resetBtn.textContent = `↻ ${t.reset}`;

            // Update category selector
            const categoryHeader = document.querySelector('.category-selector h3');
            if (categoryHeader) categoryHeader.textContent = t.selectCategory;
            
            const manageBtn = document.querySelector('.manage-btn');
            if (manageBtn) manageBtn.textContent = `⚙️ ${t.manage}`;

            // Update active timer info
            const activeTimerInfo = document.getElementById('activeTimerInfo');
            if (activeTimerInfo) {
                const categoryName = document.getElementById('activeCategoryName')?.textContent || '';
                activeTimerInfo.innerHTML = `<p>${t.tracking}: <strong id="activeCategoryName">${categoryName}</strong></p>`;
            }

            // Update manual entry
            const manualEntryHeader = document.querySelector('.manual-entry-section h3');
            if (manualEntryHeader) manualEntryHeader.textContent = `📝 ${t.manualEntry}`;
            
            const manualCategoryLabel = document.querySelector('label[for="manualCategory"]');
            if (manualCategoryLabel) manualCategoryLabel.textContent = t.category;
            
            const manualSubcategoryLabel = document.querySelector('label[for="manualSubcategory"]');
            if (manualSubcategoryLabel) manualSubcategoryLabel.textContent = t.subcategory;
            
            const manualStartTimeLabel = document.querySelector('label[for="manualStartTime"]');
            if (manualStartTimeLabel) manualStartTimeLabel.textContent = t.startTime;
            
            const manualEndTimeLabel = document.querySelector('label[for="manualEndTime"]');
            if (manualEndTimeLabel) manualEndTimeLabel.textContent = t.endTime;
            
            const addRecordBtn = document.querySelector('.btn-add');
            if (addRecordBtn) addRecordBtn.textContent = `➕ ${t.addRecord}`;

            // Update goals section
            const goalsHeader = document.querySelector('.goals-header h3');
            if (goalsHeader) goalsHeader.textContent = `📋 ${t.planAndGoals}`;
            
            const addGoalBtn = document.querySelector('.btn-goal-add');
            if (addGoalBtn) addGoalBtn.textContent = `➕ ${t.addGoal}`;

            // Update logs & stats
            const statsHeader = document.querySelector('.overview-header h3');
            if (statsHeader) statsHeader.textContent = `📈 ${t.statistics}`;
            
            const timeByCategoryHeader = document.querySelector('.category-stats h3');
            if (timeByCategoryHeader) timeByCategoryHeader.textContent = t.timeByCategory;
            
            const overviewHeader = document.querySelector('.overview-section .overview-header h3');
            if (overviewHeader) overviewHeader.textContent = `📊 ${t.overview}`;

            // Update stats range options
            const statsRange = document.getElementById('statsRange');
            if (statsRange) {
                const options = statsRange.querySelectorAll('option');
                if (options.length >= 5) {
                    options[0].textContent = t.day;
                    options[1].textContent = t.week;
                    options[2].textContent = t.month;
                    options[3].textContent = t.year;
                    options[4].textContent = t.allTime;
                }
            }

            // Update language modal
            const langModalTitle = document.querySelector('#languageModal h2');
            if (langModalTitle) langModalTitle.textContent = `🌐 ${t.chooseLanguage}`;

            // Update view toggle buttons
            const trackerBtn = document.getElementById('trackerBtn');
            if (trackerBtn) trackerBtn.textContent = t.timer;
            
            const logsBtn = document.getElementById('logsBtn');
            if (logsBtn) logsBtn.textContent = t.logsStats;

            // Update stats date label
            const statsDateLabel = document.querySelector('label[for="statsDate"]');
            if (statsDateLabel) statsDateLabel.textContent = t.date;
            
            const statsRangeLabel = document.querySelector('label[for="statsRange"]');
            if (statsRangeLabel) statsRangeLabel.textContent = t.view;

            // Update manual entry subcategory option
            const manualSubcategorySelect = document.getElementById('manualSubcategory');
            if (manualSubcategorySelect && manualSubcategorySelect.options.length > 0) {
                manualSubcategorySelect.options[0].textContent = t.noSubcategory;
            }

            // Re-render goals to update translations
            renderGoalsProgress();

            // Re-render categories to update any translated text
            renderCategories();
        }

        function getAllData() {
            return {
                version: '1.0',
                exportDate: new Date().toISOString(),
                timeLogs: timeLogs,
                customCategories: customCategories,
                customSubcategories: customSubcategories,
                modifiedDefaults: modifiedDefaults,
                deletedDefaults: deletedDefaults,
                hiddenSubcategories: JSON.parse(localStorage.getItem('hiddenSubcategories') || '{}')
            };
        }

        function exportData() {
            const data = getAllData();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `time-tracker-backup-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('✅ Data exported successfully!\n\nTransfer this file to your other device and use "Upload Data File" to import.');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    processImportedData(data);
                } catch (err) {
                    alert('❌ Error reading file. Please make sure it\'s a valid Hourglass backup file.');
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        }

        function processImportedData(data) {
            if (!data.timeLogs && !data.customCategories) {
                alert('❌ Invalid data format. This doesn\'t appear to be a Hourglass backup.');
                return;
            }

            const mergeChoice = confirm(
                '📥 Data found!\n\n' +
                `• ${(data.timeLogs || []).length} time logs\n` +
                `• ${(data.customCategories || []).length} custom categories\n\n` +
                'Choose merge option:\n' +
                '• OK = Merge with existing data (keep both)\n' +
                '• Cancel = Replace all data (overwrite)'
            );

            if (mergeChoice) {
                // Merge data
                if (data.timeLogs) {
                    const existingIds = new Set(timeLogs.map(l => l.id));
                    data.timeLogs.forEach(log => {
                        if (!existingIds.has(log.id)) {
                            timeLogs.push(log);
                        }
                    });
                }
                if (data.customCategories) {
                    const existingIds = new Set(customCategories.map(c => c.id));
                    data.customCategories.forEach(cat => {
                        if (!existingIds.has(cat.id)) {
                            customCategories.push(cat);
                        }
                    });
                }
                if (data.customSubcategories) {
                    Object.keys(data.customSubcategories).forEach(catId => {
                        if (!customSubcategories[catId]) {
                            customSubcategories[catId] = [];
                        }
                        data.customSubcategories[catId].forEach(sub => {
                            if (!customSubcategories[catId].includes(sub)) {
                                customSubcategories[catId].push(sub);
                            }
                        });
                    });
                }
            } else {
                // Replace all
                timeLogs = data.timeLogs || [];
                customCategories = data.customCategories || [];
                customSubcategories = data.customSubcategories || {};
                modifiedDefaults = data.modifiedDefaults || {};
                deletedDefaults = data.deletedDefaults || [];
                if (data.hiddenSubcategories) {
                    localStorage.setItem('hiddenSubcategories', JSON.stringify(data.hiddenSubcategories));
                }
            }

            // Save all
            saveLogs();
            saveCustomCategories();
            saveCustomSubcategories();
            saveModifiedDefaults();
            saveDeletedDefaults();

            // Refresh UI
            renderCategories();
            updateLogsView();
            updateManualCategoryDropdown();

            alert('✅ Data imported successfully!\n\nYour time logs and settings have been synced.');
            closeSyncModal();
        }

        function copySyncCode() {
            const data = getAllData();
            const compressed = btoa(encodeURIComponent(JSON.stringify(data)));
            
            navigator.clipboard.writeText(compressed).then(() => {
                document.getElementById('syncCodeDisplay').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('syncCodeDisplay').style.display = 'none';
                }, 3000);
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = compressed;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                document.getElementById('syncCodeDisplay').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('syncCodeDisplay').style.display = 'none';
                }, 3000);
            });
        }

        function importSyncCode() {
            const input = document.getElementById('syncCodeInput');
            const code = input.value.trim();
            
            if (!code) {
                alert('Please paste a sync code first.');
                return;
            }

            try {
                const json = decodeURIComponent(atob(code));
                const data = JSON.parse(json);
                processImportedData(data);
                input.value = '';
            } catch (err) {
                alert('❌ Invalid sync code. Please make sure you copied the entire code.');
            }
        }

        // Initialize on load
        init();
        
        // Initialize Firebase if configured
        initFirebase();

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('Service Worker registered'))
                    .catch(err => console.log('Service Worker registration failed:', err));
            });
        }

        // Install prompt handling
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            // Show install button if needed
            showInstallButton();
        });

        function showInstallButton() {
            // Add install button to header if not already there
            if (!document.getElementById('installBtn')) {
                const header = document.querySelector('.app-header');
                if (header) {
                    const btn = document.createElement('button');
                    btn.id = 'installBtn';
                    btn.className = 'install-btn';
                    btn.innerHTML = '📲 Install App';
                    btn.onclick = installApp;
                    header.appendChild(btn);
                }
            }
        }

        function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted install');
                    }
                    deferredPrompt = null;
                    const btn = document.getElementById('installBtn');
                    if (btn) btn.remove();
                });
            }
        }

        window.addEventListener('appinstalled', () => {
            console.log('App installed');
            const btn = document.getElementById('installBtn');
            if (btn) btn.remove();
        });
    </script>
</body>
</html>
